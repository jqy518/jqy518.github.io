<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>蒋青云的个人博客</title>
  
  <subtitle>比你聪明的家伙却比你更努力，多么可怕！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jekion.com/"/>
  <updated>2019-06-09T00:51:13.082Z</updated>
  <id>http://jekion.com/</id>
  
  <author>
    <name>jekion</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Typescript笔记07-类装饰器</title>
    <link href="http://jekion.com/2018/10/03/ts7_decorators/"/>
    <id>http://jekion.com/2018/10/03/ts7_decorators/</id>
    <published>2018-10-03T10:00:20.000Z</published>
    <updated>2019-06-09T00:51:13.082Z</updated>
    
    <content type="html"><![CDATA[<p> 类装饰器应用于类构造函数，可以用来监视，修改或替换类定义。 类装饰器不能用在声明文件中( .d.ts)，也不能用在任何外部上下文中（比如declare的类）。<br> <a id="more"></a><br> 类装饰器表达式会在运行时当作函数被调用，<code>类的构造函数</code>(即类本身)作为其唯一的参数。<br> 如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classDecorator</span>&lt;<span class="title">T</span> <span class="title">extends</span> </span>&#123;<span class="keyword">new</span>(...args:any[]):&#123;&#125;&#125;&gt;(<span class="keyword">constructor</span>:T) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">constructor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> className = <span class="string">"box"</span></span><br><span class="line">    hello = <span class="string">"override"</span> <span class="comment">//覆盖</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@classDecorator</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">  property = <span class="string">"property"</span>;</span><br><span class="line">  hello:string;</span><br><span class="line">  <span class="keyword">constructor</span> (m:string)&#123;</span><br><span class="line">    <span class="keyword">this</span>.hello = m;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h4><p> 方法装饰器声明在一个方法的声明之前（紧靠着方法声明）。 它会被应用到方法的 属性描述符上，可以用来监视，修改或者替换方法定义。 方法装饰器不能用在声明文件( .d.ts)，重载或者任何外部上下文（比如declare的类）中。<br> 方法装饰器表达式会在运行时当作函数被调用，传入下列3个参数：</p><ol><li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li><li>成员的名字。</li><li>成员的属性描述符。( 如果代码输出目标版本小于ES5，属性描述符将会是undefined)</li></ol><blockquote><p>如果方法装饰器返回一个值，它会被用作方法的属性描述符。</p></blockquote><p>下面例子是一个简单方法调用日志打印：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enumerable</span>(<span class="params">b:boolean</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target:any,propertyKey:string,descriptor:PropertyDescriptor</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oldValue = descriptor.value;</span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`函数:<span class="subst">$&#123;propertyKey&#125;</span>,参数是：<span class="subst">$&#123;args&#125;</span>`</span>)</span><br><span class="line">      <span class="keyword">return</span> oldValue.apply(<span class="keyword">this</span>,args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  name:string = <span class="string">"zhangsan"</span>;</span><br><span class="line">  @enumerable(<span class="literal">false</span>)</span><br><span class="line">  showBox(a:number,<span class="attr">b</span>:number)&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="访问器装饰器"><a href="#访问器装饰器" class="headerlink" title="访问器装饰器"></a>访问器装饰器</h4><p>访问器装饰器声明在一个访问器的声明之前（紧靠着访问器声明）。 访问器装饰器应用于访问器的 属性描述符并且可以用来监视，修改或替换一个访问器的定义。 访问器装饰器不能用在声明文件中（.d.ts），或者任何外部上下文（比如 declare的类）里。</p><blockquote><p>注意  TypeScript不允许同时装饰一个成员的get和set访问器。取而代之的是，一个成员的所有装饰的必须应用在文档顺序的第一个访问器上。这是因为，在装饰器应用于一个属性描述符时，它联合了get和set访问器，而不是分开声明的。</p></blockquote><p>传入3个参数与方法装饰器入参一样。<br><br>如果访问器装饰器返回一个值，它会被用作方法的属性描述符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">accessFun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target:any,proprty:string,descriptor:PropertyDescriptor</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> oget = descriptor.get;</span><br><span class="line">    <span class="keyword">let</span> oset = descriptor.set;</span><br><span class="line">    descriptor.get = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"调用get方法:"</span>)</span><br><span class="line">      <span class="keyword">return</span> oget.apply(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    descriptor.set = <span class="function"><span class="keyword">function</span> (<span class="params">...arg</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"调用set方法"</span>)</span><br><span class="line">      oset.apply(<span class="keyword">this</span>,arg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  private _x = <span class="number">0</span>;</span><br><span class="line">  private _y = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(x:number,y:number)&#123;</span><br><span class="line">    <span class="keyword">this</span>._x = x;</span><br><span class="line">    <span class="keyword">this</span>._y = y;</span><br><span class="line">  &#125; </span><br><span class="line">  @accessFun()</span><br><span class="line">  get x() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._x;</span><br><span class="line">  &#125;</span><br><span class="line">  get y()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._y;</span><br><span class="line">  &#125;</span><br><span class="line">  set x(x:number)&#123;</span><br><span class="line">    <span class="keyword">this</span>._x = x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> point = <span class="keyword">new</span> Point(<span class="number">12</span>,<span class="number">15</span>);</span><br><span class="line"><span class="built_in">console</span>.log(point.x);</span><br><span class="line">point.x = <span class="number">36</span>;</span><br><span class="line"><span class="built_in">console</span>.log(point.x);</span><br></pre></td></tr></table></figure><h4 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h4><p>属性装饰器声明在一个属性声明之前（紧靠着属性声明）。 属性装饰器不能用在声明文件中（.d.ts），或者任何外部上下文（比如 declare的类）里。</p><p>装饰器入参：</p><ol><li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li><li>成员的名字。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"reflect-metadata"</span> <span class="comment">//给类成员添加元信息</span></span><br><span class="line"><span class="keyword">const</span> key = <span class="string">"keyname"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format</span>(<span class="params">fstr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Reflect</span>.metadata(key,str)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  @format(<span class="string">'_x value is: %s'</span>)</span><br><span class="line">  private _x:number = <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = Point();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.getMetaData(key,p,<span class="string">"_x"</span>)) <span class="comment">//"_x value is: %s"</span></span><br></pre></td></tr></table></figure><h4 id="参数装饰器"><a href="#参数装饰器" class="headerlink" title="参数装饰器:"></a>参数装饰器:</h4><p>参数装饰器声明在一个参数声明之前（紧靠着参数声明）。 参数装饰器应用于类构造函数或方法声明。 参数装饰器不能用在声明文件（.d.ts），重载或其它外部上下文（比如 declare的类）里。</p><p>入参：</p><ol><li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li><li>成员的名字。(方法的名称)</li><li>参数在函数参数列表中的索引。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">paramsInfo</span>(<span class="params">target:Object,pname:string, index:number</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(pname);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  run(@paramsInfo load:string) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> Car(); <span class="comment">//run</span></span><br></pre></td></tr></table></figure><h4 id="装饰器工厂与装饰器组合"><a href="#装饰器工厂与装饰器组合" class="headerlink" title="装饰器工厂与装饰器组合"></a>装饰器工厂与装饰器组合</h4><p>  装饰器工厂就是一个简单的函数，它返回一个表达式，以供装饰器在运行时调用。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enumerable</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个装饰器可以同时应用到一个声明上,如:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@f</span><br><span class="line">@b</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">c</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种组合装修器执行顺序如下:</p><blockquote><p>1、上至下依次对装饰器表达式求值。<br><br>2、求值的结果会被<code>当作函数</code>，由下至上依次调用。</p></blockquote><p>简单的说就是由外到内，再由内到外</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 类装饰器应用于类构造函数，可以用来监视，修改或替换类定义。 类装饰器不能用在声明文件中( .d.ts)，也不能用在任何外部上下文中（比如declare的类）。&lt;br&gt;
    
    </summary>
    
    
      <category term="typescript" scheme="http://jekion.com/tags/typescript/"/>
    
      <category term="ts" scheme="http://jekion.com/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>Typescript笔记06-高级类型</title>
    <link href="http://jekion.com/2018/10/02/ts6_advanced/"/>
    <id>http://jekion.com/2018/10/02/ts6_advanced/</id>
    <published>2018-10-02T10:00:20.000Z</published>
    <updated>2019-06-09T00:50:23.540Z</updated>
    
    <content type="html"><![CDATA[<h4 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h4><p>交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。<br><a id="more"></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  name:string</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  age:number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="xml"><span class="tag">&lt;<span class="name">A</span> &amp; <span class="attr">B</span>&gt;</span> &#123;&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">c = &#123;name:"zhangsan"&#125; //error</span></span><br><span class="line"><span class="xml">c = &#123;name:"zhangsan",age:12&#125; //success</span></span><br></pre></td></tr></table></figure><h4 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h4><p>联合类型表示一个值可以是几种类型之一。 我们用竖线（ |）分隔每个类型，所以<code>number | string | boolean</code>表示一个值可以是 <code>number， string，或 boolean</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span> (<span class="params">name:string,age:string | number</span>)</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">myFun(<span class="string">"zhangsan"</span>, <span class="literal">true</span>) <span class="comment">//error</span></span><br><span class="line">myFun(<span class="string">"zhangsan"</span>, <span class="number">12</span>) <span class="comment">//success</span></span><br></pre></td></tr></table></figure><p>联合类型的变量，我们只能访问此联合类型的所有类型里<code>共有的成员</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface Bird &#123;</span><br><span class="line">    fly();</span><br><span class="line">    layEggs();</span><br><span class="line">&#125;</span><br><span class="line">interface Fish &#123;</span><br><span class="line">    swim();</span><br><span class="line">    layEggs();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSmallPet</span>(<span class="params"></span>): <span class="title">Fish</span> | <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> pet = getSmallPet();</span><br><span class="line">pet.layEggs(); <span class="comment">// okay</span></span><br><span class="line">pet.swim();    <span class="comment">// errors</span></span><br></pre></td></tr></table></figure><h4 id="类型保护与区分类型"><a href="#类型保护与区分类型" class="headerlink" title="类型保护与区分类型"></a>类型保护与区分类型</h4><p>如上面代码，如果我们想让它正常工作；我们可以检查成员是否存在y方法，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pet = getSmallPet();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一个成员访问都会报错</span></span><br><span class="line"><span class="keyword">if</span> (pet.swim) &#123; <span class="comment">//error</span></span><br><span class="line">    pet.swim();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pet.fly) &#123; <span class="comment">//error</span></span><br><span class="line">    pet.fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但我们发现在typeScript里面还是报错；为了让这段代码工作，我们要使用类型断言：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="xml"><span class="tag">&lt;<span class="name">Fish</span>&gt;</span>pet.swim) &#123; //success</span></span><br><span class="line"><span class="xml">    pet.swim();</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line">else if (&lt;Bird&gt;pet.fly) &#123; //success</span><br><span class="line">    pet.fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用户自定义的类型保护"><a href="#用户自定义的类型保护" class="headerlink" title="用户自定义的类型保护"></a>用户自定义的类型保护</h4><p>其实我们发现上面代码<code>else if</code>里也用了断言，而不能直接用<code>else</code>否则还是会报错，尽量<code>pet</code>类型不是<code>Fish</code>就是<code>Bird</code>; 假若我们一旦检查过类型，就能在之后的每个分支里清楚地知道 pet的类型的话就好了。TypeScript里的 类型保护机制让它成为了现实。</p><blockquote><p>类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。 要定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个 类型谓词：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFish</span>(<span class="params">pet: Fish | Bird</span>): <span class="title">pet</span> <span class="title">is</span> <span class="title">Fish</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">Fish</span>&gt;</span>pet).swim !== undefined;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>在这个例子里， <code>pet is Fish</code>就是类型谓词。 谓词为 <code>parameterName is Type</code>这种形式， <code>parameterName</code>必须是来自于当前函数签名里的一个参数名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (isFish(pet)) &#123;</span><br><span class="line">    pet.swim();</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    pet.fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意TypeScript不仅知道在 if分支里 pet是 Fish类型； 它还清楚在 else分支里，一定 不是 Fish类型，一定是 Bird类型。</p></blockquote><p>但我们发现定义这样一个类型保护函数也是件很麻烦的事情；</p><h4 id="typeof，instanceof类型保护"><a href="#typeof，instanceof类型保护" class="headerlink" title="typeof，instanceof类型保护"></a>typeof，instanceof类型保护</h4>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;交叉类型&quot;&gt;&lt;a href=&quot;#交叉类型&quot; class=&quot;headerlink&quot; title=&quot;交叉类型&quot;&gt;&lt;/a&gt;交叉类型&lt;/h4&gt;&lt;p&gt;交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。&lt;br&gt;
    
    </summary>
    
    
      <category term="typescript" scheme="http://jekion.com/tags/typescript/"/>
    
      <category term="ts" scheme="http://jekion.com/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>Typescript笔记05-类型兼容性</title>
    <link href="http://jekion.com/2018/09/18/ts5_compatibility/"/>
    <id>http://jekion.com/2018/09/18/ts5_compatibility/</id>
    <published>2018-09-18T10:00:20.000Z</published>
    <updated>2019-06-09T00:47:39.564Z</updated>
    
    <content type="html"><![CDATA[<p>TypeScript里的类型兼容性是基于<code>结构子类型</code>的。 结构类型是一种只使用其<code>成员</code>来描述类型的方式。 它正好与名义（nominal）类型形成对比。（译者注：在基于名义类型的类型系统中，数据类型的兼容性或等价性是通过明确的声明和/或类型的名称来决定的。这与结构性类型系统不同，它是基于类型的组成结构，且不要求明确地声明。） 看下面的例子：<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface ABox &#123;</span><br><span class="line">  name:<span class="built_in">String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BBox</span> </span>&#123;</span><br><span class="line">  name:<span class="built_in">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> abox:ABox</span><br><span class="line"><span class="keyword">let</span> bbox = <span class="keyword">new</span> BBox()</span><br><span class="line">abox = bbox; <span class="comment">//赋值成功</span></span><br></pre></td></tr></table></figure></p><blockquote><p>TypeScript的结构性子类型是根据JavaScript代码的典型写法来设计的。 因为JavaScript里广泛地使用<code>匿名对象</code>，例如<code>函数表达式</code>和<code>对象字面量</code>，所以使用结构类型系统来描述这些类型比使用名义类型系统更好。</p></blockquote><p>TypeScript结构化类型系统的基本规则是，如果x要兼容y，那么y至少具有与x相同的属性,（y如果存在比x多的属性也没有关系）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface ABox &#123;</span><br><span class="line">  name:<span class="built_in">String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> abox:ABox</span><br><span class="line"><span class="keyword">let</span> c = &#123;<span class="attr">age</span>:<span class="number">12</span>&#125;</span><br><span class="line">abox = c <span class="comment">//报错，找不到name</span></span><br><span class="line"><span class="keyword">let</span> d = &#123;<span class="attr">age</span>:<span class="number">12</span>,<span class="attr">name</span>:<span class="string">'zhangsan'</span>&#125;</span><br><span class="line">abox = d <span class="comment">//成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//检查函数参数时使用相同的规则</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">arg:ABox</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.name)</span><br><span class="line">&#125;</span><br><span class="line">getName(&#123;<span class="attr">age</span>:<span class="number">26</span>&#125;) <span class="comment">//error</span></span><br><span class="line">getName(&#123;<span class="attr">age</span>:<span class="number">26</span>,<span class="attr">name</span>:<span class="string">'zhangsan'</span>&#125;) <span class="comment">//success</span></span><br></pre></td></tr></table></figure><h4 id="比较两个函数"><a href="#比较两个函数" class="headerlink" title="比较两个函数"></a>比较两个函数</h4><p>1)比较入参</p><p>要查看x是否能赋值给y，首先看它们的参数列表。 x的每个参数必须能在y里找到对应类型的参数。 注意的是参数的名字相同与否无所谓，只看它们的类型。 这里， x的每个参数在y中都能找到对应的参数，所以允许赋值。</p><blockquote><p>因为：忽略参数在js中很常见。想想<code>forEach</code>回调函数^_^</p></blockquote><p>2）比较返回值</p><p>类型系统强制源函数的返回值类型必须是目标函数返回值类型的<code>子类型</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> funA = <span class="function">(<span class="params">age:<span class="built_in">Number</span></span>)=&gt;</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> funB = <span class="function">(<span class="params">a:<span class="built_in">Number</span></span>) =&gt;</span> <span class="number">0</span></span><br><span class="line">funA = funB <span class="comment">//success</span></span><br></pre></td></tr></table></figure><h4 id="函数参数双向协变"><a href="#函数参数双向协变" class="headerlink" title="函数参数双向协变"></a>函数参数双向协变</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">enum EventType &#123;MouseEvent,KeyEvent&#125;</span><br><span class="line"></span><br><span class="line">interface Event &#123;<span class="attr">timestamp</span>:number&#125;</span><br><span class="line">interface MouseEvent extends Event &#123;</span><br><span class="line">  mx: number</span><br><span class="line">  my: number</span><br><span class="line">&#125;</span><br><span class="line">interface KeyEvent extends Event &#123;</span><br><span class="line">  code:string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listenEvent</span> (<span class="params">type:EventType,cb:(e:Event</span>)=&gt;<span class="title">void</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//常见操作</span></span><br><span class="line">listenEvent(EventType.MouseEvent,<span class="function"><span class="keyword">function</span>(<span class="params">e:MouseEvent</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.x,e.y)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">listenEvent(EventType.MouseEvent,<span class="function"><span class="keyword">function</span>(<span class="params">e:Event</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log((&lt;MouseEvent&gt;e).x,(&lt;MouseEvent&gt;e).y) //断言为子类MouseEvent</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TypeScript里的类型兼容性是基于&lt;code&gt;结构子类型&lt;/code&gt;的。 结构类型是一种只使用其&lt;code&gt;成员&lt;/code&gt;来描述类型的方式。 它正好与名义（nominal）类型形成对比。（译者注：在基于名义类型的类型系统中，数据类型的兼容性或等价性是通过明确的声明和/或类型的名称来决定的。这与结构性类型系统不同，它是基于类型的组成结构，且不要求明确地声明。） 看下面的例子：&lt;br&gt;
    
    </summary>
    
    
      <category term="typescript" scheme="http://jekion.com/tags/typescript/"/>
    
      <category term="ts" scheme="http://jekion.com/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>Typescript笔记04-类型推论</title>
    <link href="http://jekion.com/2018/09/17/ts4_inference/"/>
    <id>http://jekion.com/2018/09/17/ts4_inference/</id>
    <published>2018-09-17T10:10:20.000Z</published>
    <updated>2019-06-09T00:45:39.898Z</updated>
    
    <content type="html"><![CDATA[<p>TypeScript里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">3</span></span><br></pre></td></tr></table></figure></p><p><code>a</code>的类型被推断为数字。 这种推断发生在<code>初始化变量和成员</code>，<code>设置默认参数值</code>和<code>决定函数返回值时</code>。</p><h4 id="最佳通用类型"><a href="#最佳通用类型" class="headerlink" title="最佳通用类型"></a>最佳通用类型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">2</span>,<span class="string">'name'</span>]</span><br></pre></td></tr></table></figure><p>上面情况，TypeScript会考虑所有元素情况，并给出一个兼容所有候选类型的类型。<code>(number | string)[]</code></p><p>有些时候候选类型共享相同的通用类型，但是却没有一个类型能做为所有候选类型的类型。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> types = [<span class="keyword">new</span> B(),<span class="keyword">new</span> C()]</span><br></pre></td></tr></table></figure></p><p>如上面如果不明确指定types的类型，找不到最佳通用类型的话，类型推断的结果为联合数组类型，<code>(B | C )[]</code>。我们可以明细指定types的类型为 <code>A[]</code></p><h3 id="上下文类型"><a href="#上下文类型" class="headerlink" title="上下文类型"></a>上下文类型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params">mouseEvent</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(mouseEvent.button);  <span class="comment">//&lt;- Error</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个例子会得到一个类型错误，TypeScript类型检查器使用Window.onmousedown函数的类型来推断右边函数表达式的类型。 因此，就能推断出 mouseEvent参数的类型了。 如果函数表达式不是在上下文类型的位置， mouseEvent参数的类型需要指定为any，这样也不会报错了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params">mouseEvent: any</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(mouseEvent.button);  <span class="comment">//&lt;- Now, no error is given</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TypeScript里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。&lt;br&gt;
    
    </summary>
    
    
      <category term="typescript" scheme="http://jekion.com/tags/typescript/"/>
    
      <category term="ts" scheme="http://jekion.com/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>Typescript笔记02-函数类型</title>
    <link href="http://jekion.com/2018/09/16/ts2_function/"/>
    <id>http://jekion.com/2018/09/16/ts2_function/</id>
    <published>2018-09-16T10:10:20.000Z</published>
    <updated>2019-06-09T00:39:38.585Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a:number,b:number</span>):<span class="title">number</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a +b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="function"><span class="keyword">function</span>(<span class="params">a:number,b:number</span>):<span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ps:TypeScript能够根据返回语句自动推断出返回值类型，因此我们通常省略它。<br><a id="more"></a></p></blockquote><h4 id="完整的函数类型"><a href="#完整的函数类型" class="headerlink" title="完整的函数类型"></a>完整的函数类型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> addfull:<span class="function">(<span class="params">a: number ,b: number</span>)=&gt;</span>number = <span class="function"><span class="keyword">function</span>(<span class="params">x:number,y:string</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数类型包含两部分：参数类型和返回值类型。 当写出完整函数类型的时候，这两部分都是需要的。 我们以参数列表的形式写出参数类型，为每个参数指定一个名字和类型。 这个名字只是为了增加可读性。只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。所以我们可以看到上面例子中函数入参名与类型定义时参数名不一致也是可以的。</p><p>第二部分是返回值类型。 对于返回值，我们在函数和返回值类型之前使用<code>( =&gt;)</code>符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为<code>void</code>而不能留空。</p><h4 id="推断类型"><a href="#推断类型" class="headerlink" title="推断类型"></a>推断类型</h4><p>如果你在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript编译器会自动识别出类型,这叫做<code>“按上下文归类”</code>，是类型推论的一种。 如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">a:number, b:number</span>):<span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a +b ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//完整定义</span></span><br><span class="line"><span class="keyword">let</span> addFull:<span class="function">(<span class="params">a:number,b:number</span>)=&gt;</span>number = </span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x+y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h3><p>TypeScript里的每个函数参数都是必须的。 这不是指不能传递 null或undefined作为参数，而是说编译器检查用户是否为每个参数都传入了值。 编译器还会假设只有这些参数会被传递进函数。 简短地说，<code>传递给一个函数的参数个数必须与函数期望的参数个数一致</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> addFull:<span class="function">(<span class="params">a:number,b:number</span>)=&gt;</span>number = </span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x+y</span><br><span class="line">&#125;</span><br><span class="line">addFull(<span class="number">1</span>) <span class="comment">//错误</span></span><br><span class="line">addFull(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">addFull(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment">//错误</span></span><br></pre></td></tr></table></figure></p><p>在TypeScript里我们可以在参数名旁使用 ?实现可选参数的功能。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write</span> (<span class="params">firstName:string,lastName:string,age?:number</span>):<span class="title">string</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName+lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">write(<span class="string">'san'</span>,<span class="string">'zhang'</span>);</span><br><span class="line">write(<span class="string">'san'</span>,<span class="string">'zhang'</span>,<span class="number">9</span>);</span><br></pre></td></tr></table></figure></p><blockquote><p>ps:可选参数必须跟在必须参数后面。</p></blockquote><h4 id="默认初始化值的参数"><a href="#默认初始化值的参数" class="headerlink" title="默认初始化值的参数"></a>默认初始化值的参数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: string, lastName = <span class="string">"Smith"</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">" "</span> + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认参数如果跟可选参数一样放在必选参数后面，则默然参数也可<code>视为可选参数</code>与可以参数共享<code>参数类型</code>(即参数类型定义是一样的)，默认参数的<code>默认值</code>并不会在类型定义中体现，只保留了它是一个可选参数的信息。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">fname:string,lname?:string</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fname + <span class="string">''</span> + lname;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">fname:string,lname=<span class="string">'huang'</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fname + <span class="string">''</span> + lname;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面两个函数共享同样的类型(fname: string, lname?: string) =&gt; string。</span></span><br></pre></td></tr></table></figure></p><p>默认参数如果放在必选参数前面，则用户必须明确的传入<code>undefined</code>值来获得默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">lname=<span class="string">'huang'</span>,fname:string</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fname + <span class="string">''</span> + lname;</span><br><span class="line">&#125;</span><br><span class="line">getName(<span class="literal">undefined</span>,<span class="string">'xiaoming'</span>)</span><br></pre></td></tr></table></figure><h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来;此时你可以使用如下方法把剩余参数收集到一个变量中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: string, ...restOfName: string[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">" "</span> + restOfName.join(<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><p>TypeScript箭头函数与显示申明使用。<br>显示申明<code>this</code>代码如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name:<span class="string">"zhangsan"</span>,</span><br><span class="line">  someFun:<span class="function"><span class="keyword">function</span>(<span class="params">this:obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;a:number,b:number&lt;/span&gt;):&lt;span class=&quot;title&quot;&gt;number&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a +b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; myAdd = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;a:number,b:number&lt;/span&gt;):&lt;span class=&quot;title&quot;&gt;number&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a+b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;ps:TypeScript能够根据返回语句自动推断出返回值类型，因此我们通常省略它。&lt;br&gt;
    
    </summary>
    
    
      <category term="typescript" scheme="http://jekion.com/tags/typescript/"/>
    
      <category term="ts" scheme="http://jekion.com/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>Typescript笔记01-类的继承</title>
    <link href="http://jekion.com/2018/09/15/ts1_class/"/>
    <id>http://jekion.com/2018/09/15/ts1_class/</id>
    <published>2018-09-15T10:20:20.000Z</published>
    <updated>2019-06-09T00:31:56.271Z</updated>
    
    <content type="html"><![CDATA[<p>当父类有构造器函数时，子类中如果申明构造器函数，则必须在使用<code>this</code>前使用<code>super()</code>调用父类构造器；子类不定义构造器默然会被添加代码如下：<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">    <span class="keyword">super</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="公共，私有与受保护的修饰符"><a href="#公共，私有与受保护的修饰符" class="headerlink" title="公共，私有与受保护的修饰符"></a>公共，私有与受保护的修饰符</h3><p>默认为<code>public</code>;<br>TypeScript使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。看下例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  name:<span class="built_in">String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  name:<span class="built_in">String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ac = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">let</span> bc = <span class="keyword">new</span> B();</span><br><span class="line">ac = bc <span class="comment">//bc赋值给ac并不会报错，尽管他们是不同类的实例</span></span><br></pre></td></tr></table></figure></p><p>然而，当我们比较带有 private或 protected成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 private成员，那么只有当另外一个类型中也存在这样一个 private成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 protected成员也使用这个规则。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  private age:<span class="built_in">Number</span></span><br><span class="line">  name:<span class="built_in">String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  private age:<span class="built_in">Number</span></span><br><span class="line">  name:<span class="built_in">String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ac = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">let</span> bc = <span class="keyword">new</span> B();</span><br><span class="line">ac = bc <span class="comment">//错误</span></span><br></pre></td></tr></table></figure></p><p><code>protected</code>修饰符与 <code>private</code>修饰符的行为很相似，但有一点不同， <code>protected</code>成员在派生类中仍然可以访问。构造函数也可以使用<code>protected</code>;则此类只能在其子类中实例化，不能直接通过<code>new</code>在外部实例化。<br>如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  private age:<span class="built_in">Number</span>;</span><br><span class="line">  public name:<span class="built_in">String</span></span><br><span class="line">  protected <span class="keyword">constructor</span>()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>(); <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ac = <span class="keyword">new</span> A(); <span class="comment">//错误</span></span><br></pre></td></tr></table></figure></p><h3 id="readonly修饰符"><a href="#readonly修饰符" class="headerlink" title="readonly修饰符"></a>readonly修饰符</h3><p>你可以使用<code>readonly</code>关键字将属性设置为只读的。 只读属性必须在<code>声明</code>时或<code>构造函数</code>里被初始化。</p><h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><p>我们可以通过参数属性在<code>constructor</code>构造函数中定义并初始化成员。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (public name:String,private age:Number)&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ai = <span class="keyword">new</span> A(<span class="string">'zhangsan'</span>,<span class="number">23</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ai.name) <span class="comment">//zhangsan</span></span><br></pre></td></tr></table></figure></p><h3 id="存取器getters和setters方法："><a href="#存取器getters和setters方法：" class="headerlink" title="存取器getters和setters方法："></a>存取器getters和setters方法：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  private _name:<span class="built_in">String</span></span><br><span class="line"></span><br><span class="line">  get yName():<span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">  &#125;</span><br><span class="line">  set yName(name:<span class="built_in">String</span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>._name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ai = <span class="keyword">new</span> A();</span><br><span class="line">ai.yName = <span class="string">"zhangsan"</span></span><br><span class="line"><span class="built_in">console</span>.log(ai.yName)</span><br></pre></td></tr></table></figure><blockquote><p>ps:首先，存取器要求你将编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3。 其次，只带有 get不带有 set的存取器自动被推断为 readonly。 这在从代码生成 .d.ts文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。</p></blockquote><h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>我们可以通过<code>static</code>创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> point = &#123;<span class="attr">x</span>:<span class="number">10</span>,<span class="attr">y</span>:<span class="number">12</span>&#125;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(A.point.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.point = &#123;<span class="attr">x</span>:<span class="number">23</span>,<span class="attr">y</span>:<span class="number">36</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。 abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当父类有构造器函数时，子类中如果申明构造器函数，则必须在使用&lt;code&gt;this&lt;/code&gt;前使用&lt;code&gt;super()&lt;/code&gt;调用父类构造器；子类不定义构造器默然会被添加代码如下：&lt;br&gt;
    
    </summary>
    
    
      <category term="typescript" scheme="http://jekion.com/tags/typescript/"/>
    
      <category term="ts" scheme="http://jekion.com/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>Typescript笔记03-泛型</title>
    <link href="http://jekion.com/2018/09/13/ts3_genericity/"/>
    <id>http://jekion.com/2018/09/13/ts3_genericity/</id>
    <published>2018-09-13T10:00:20.000Z</published>
    <updated>2019-06-09T00:55:40.135Z</updated>
    
    <content type="html"><![CDATA[<h4 id="泛型变量"><a href="#泛型变量" class="headerlink" title="泛型变量"></a>泛型变量</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function fun&lt;T&gt;(arg:T):T[]&#123;</span><br><span class="line">  <span class="keyword">return</span> [arg];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr&lt;number&gt;(<span class="number">1</span>) <span class="comment">//明确指定类型</span></span><br><span class="line">arr(<span class="string">"name"</span>) <span class="comment">//利用类型推断不指类型，返回的是一个字符串数组</span></span><br></pre></td></tr></table></figure> <a id="more"></a><p>泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面如上面的<code>&lt;T&gt;</code><br>我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> otherFun:<span class="xml"><span class="tag">&lt;<span class="name">U</span>&gt;</span>(arg:U)=&gt;U = fun;</span></span><br></pre></td></tr></table></figure></p><p>我们还可以使用带有调用签名的对象字面量来定义泛型函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> otherFun:&#123;&lt;U&gt;(arg:U):U&#125; = fun;</span><br></pre></td></tr></table></figure></p><p>或是以接口的形式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface FunInterFace &#123;</span><br><span class="line">  &lt;T&gt;(arg:T):T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> otherFun:FunInterFace = fun;</span><br></pre></td></tr></table></figure></p><p>我们也可以把泛型参数当作整个接口的一个参数。 这样我们就能清楚的知道使用的具体是哪个泛型类型:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface FunInterFace&lt;T&gt; &#123;</span><br><span class="line">  (arg:T):T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> otherFun:FunInterFace&lt;nubmer&gt; = fun; <span class="comment">//我们得给接口明确指定一个泛型类型。</span></span><br></pre></td></tr></table></figure></p><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  name:T,</span><br><span class="line">  add(a:T,<span class="attr">b</span>:T):T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mclass = <span class="keyword">new</span> MyClass&lt;string&gt;();</span><br><span class="line">mclass.add = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>):<span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mclass.add(<span class="number">3</span>,<span class="string">'5'</span>) <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><p>类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。</p><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface LengthWise &#123;</span><br><span class="line">  length:number</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">LengthWise</span>&gt; (<span class="params">arg:T</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getLength(&#123;<span class="attr">length</span>:<span class="number">5</span>&#125;);</span><br><span class="line">getLength([<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>]);</span><br><span class="line">getLength(<span class="string">'5'</span>) <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><h3 id="在泛型约束中使用类型参数"><a href="#在泛型约束中使用类型参数" class="headerlink" title="在泛型约束中使用类型参数"></a>在泛型约束中使用类型参数</h3><p>你可以声明一个类型参数，且它被另一个类型参数所约束。 比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象 obj上，因此我们需要在这两个类型之间使用约束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProp</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj:T ,key:K</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;泛型变量&quot;&gt;&lt;a href=&quot;#泛型变量&quot; class=&quot;headerlink&quot; title=&quot;泛型变量&quot;&gt;&lt;/a&gt;泛型变量&lt;/h4&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function fun&amp;lt;T&amp;gt;(arg:T):T[]&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [arg];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arr&amp;lt;number&amp;gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;//明确指定类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arr(&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;//利用类型推断不指类型，返回的是一个字符串数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="typescript" scheme="http://jekion.com/tags/typescript/"/>
    
      <category term="ts" scheme="http://jekion.com/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>Typescript学习笔记-接口</title>
    <link href="http://jekion.com/2018/08/07/interface/"/>
    <id>http://jekion.com/2018/08/07/interface/</id>
    <published>2018-08-06T22:43:26.000Z</published>
    <updated>2019-06-06T23:21:04.394Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Typescript学习笔记-接口"><a href="#Typescript学习笔记-接口" class="headerlink" title="Typescript学习笔记-接口"></a>Typescript学习笔记-接口</h3><p>目标:<br><a id="more"></a></p><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface LabelledobjValue &#123;</span><br><span class="line">  label:string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">LabelledObj:LabelledobjValue</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(LabelledObj.label);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> lobj = &#123;<span class="attr">label</span>:<span class="string">"dosome"</span>&#125;</span><br><span class="line">printLabel(lobj)</span><br><span class="line">### 可选属性（可用于校验属性名）</span><br><span class="line">interface squareConfig &#123;</span><br><span class="line">  color?:string;</span><br><span class="line">  width?:string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> sconfig:squareConfig = &#123;</span><br><span class="line">  cc:<span class="string">"hahah"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="只读限制"><a href="#只读限制" class="headerlink" title="只读限制"></a>只读限制</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">  readonly x: number;</span><br><span class="line">  readonly y: number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1: Point  = &#123;<span class="attr">x</span>:<span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span>&#125;;</span><br><span class="line">p1.x = <span class="number">20</span>; <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><h3 id="ReadonlyArray类型，设为只读。"><a href="#ReadonlyArray类型，设为只读。" class="headerlink" title="ReadonlyArray类型，设为只读。"></a>ReadonlyArray<t>类型，设为只读。</t></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a:number[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> bdd:<span class="built_in">Array</span>&lt;number&gt; = [];</span><br><span class="line">bdd[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> ro:ReadonlyArray&lt;number&gt; = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">ro.push(<span class="number">8</span>); <span class="comment">//报错</span></span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">9</span>; <span class="comment">//报错</span></span><br><span class="line"><span class="keyword">let</span> copyro = ro;</span><br><span class="line">copyro.push(<span class="number">99</span>);<span class="comment">//报错</span></span><br></pre></td></tr></table></figure><h3 id="类型断言重写ReadonlyArray类型"><a href="#类型断言重写ReadonlyArray类型" class="headerlink" title="类型断言重写ReadonlyArray类型"></a>类型断言重写ReadonlyArray<t>类型</t></h3><blockquote><p>a = ro as number[]</p></blockquote><h3 id="有时候对于一个复杂的入参对象，我们对他进行接口定义可能会遇到一些麻烦："><a href="#有时候对于一个复杂的入参对象，我们对他进行接口定义可能会遇到一些麻烦：" class="headerlink" title="有时候对于一个复杂的入参对象，我们对他进行接口定义可能会遇到一些麻烦："></a>有时候对于一个复杂的入参对象，我们对他进行接口定义可能会遇到一些麻烦：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface configData  &#123;</span><br><span class="line">  color?:string;</span><br><span class="line">  age?:number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span>(<span class="params">config:configData</span>):<span class="title">void</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">initData(&#123;<span class="attr">width</span>:<span class="number">200</span>,<span class="attr">age</span>:<span class="number">23</span>&#125;) <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><h3 id="我们不能确定入参对象是否包含其他属性的时候，有三种做法可以绕开接口定义的检查："><a href="#我们不能确定入参对象是否包含其他属性的时候，有三种做法可以绕开接口定义的检查：" class="headerlink" title="我们不能确定入参对象是否包含其他属性的时候，有三种做法可以绕开接口定义的检查："></a>我们不能确定入参对象是否包含其他属性的时候，有三种做法可以绕开接口定义的检查：</h3><h3 id="1-利用断言"><a href="#1-利用断言" class="headerlink" title="1)利用断言"></a>1)利用断言</h3><blockquote><p>initData({width:200,age:23} as configData)</p><h3 id="2-给定义添加一个字符串索引签名"><a href="#2-给定义添加一个字符串索引签名" class="headerlink" title="2)给定义添加一个字符串索引签名"></a>2)给定义添加一个字符串索引签名</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> interface configData  &#123;</span><br><span class="line">  color?:string;</span><br><span class="line">  age?:number;</span><br><span class="line">  [propName: string]: any;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-直接把入参赋值给另一变量"><a href="#3-直接把入参赋值给另一变量" class="headerlink" title="3)直接把入参赋值给另一变量"></a>3)直接把入参赋值给另一变量</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> otherconfig = &#123;<span class="attr">width</span>:<span class="number">200</span>,<span class="attr">age</span>:<span class="number">23</span>&#125;;</span><br><span class="line">initData(otherconfig);</span><br></pre></td></tr></table></figure><p>ps：一般对于简单可以确定的属性的入参我们不应该绕开检查。</p><h3 id="函数类型接口定义"><a href="#函数类型接口定义" class="headerlink" title="函数类型接口定义:"></a>函数类型接口定义:</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface SearchFunc &#123;</span><br><span class="line">  (source:string,<span class="attr">subString</span>:string): boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch:SearchFunc;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">source,tt</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">mySearch(<span class="literal">false</span>,<span class="string">'fff'</span>);</span><br><span class="line"></span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">src:string,sub:string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'231'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-函数的参数名称可以与定义不一样；"><a href="#1-函数的参数名称可以与定义不一样；" class="headerlink" title="1),函数的参数名称可以与定义不一样；"></a>1),函数的参数名称可以与定义不一样；</h3><h3 id="2-如果不定义函数入参类型或返回值类型，ts会推断出相应类型（如上面例子）"><a href="#2-如果不定义函数入参类型或返回值类型，ts会推断出相应类型（如上面例子）" class="headerlink" title="2),如果不定义函数入参类型或返回值类型，ts会推断出相应类型（如上面例子）"></a>2),如果不定义函数入参类型或返回值类型，ts会推断出相应类型（如上面例子）</h3><h3 id="可索引类型定义"><a href="#可索引类型定义" class="headerlink" title="可索引类型定义"></a>可索引类型定义</h3><h4 id="我们也可以描述那些能够“通过索引得到”的类型，比如a-10-或ageMap-“daniel”-。"><a href="#我们也可以描述那些能够“通过索引得到”的类型，比如a-10-或ageMap-“daniel”-。" class="headerlink" title="我们也可以描述那些能够“通过索引得到”的类型，比如a[10]或ageMap[“daniel”]。"></a>我们也可以描述那些能够“通过索引得到”的类型，比如a[10]或ageMap[“daniel”]。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface StringArray &#123;</span><br><span class="line">  [index:number] :number</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> sArr:StringArray;</span><br><span class="line"><span class="keyword">let</span> strArr:StringArray</span><br><span class="line">sArr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">strArr = [<span class="string">'name'</span>,<span class="string">'1212'</span>,<span class="number">12</span>]</span><br></pre></td></tr></table></figure><p>可索引类型定义支持两种索引签名：<code>数字</code>与<code>字符串</code>；可以并存，但是数字索引的返回值必须是字符串索引返回值类型的子类型。<br>这是因为当使用 number来索引时，JavaScript会将它转换成string然后再去索引对象。<br>也就是说用 100（一个number）去索引等同于使用”100”（一个string）去索引，因此两者需要保持一致。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface CommonObject &#123; <span class="comment">//报错 number不是string的子类</span></span><br><span class="line">  [index:number]:number,</span><br><span class="line">  [i:string]:string </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface CommonObject2 &#123; <span class="comment">//正确 number是Object的子类</span></span><br><span class="line">  [index:number]:number,</span><br><span class="line">  [i:string]:<span class="built_in">Object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="索引签名可设置为只读，这样就防止了给索引赋值："><a href="#索引签名可设置为只读，这样就防止了给索引赋值：" class="headerlink" title="索引签名可设置为只读，这样就防止了给索引赋值："></a>索引签名可设置为只读，这样就防止了给索引赋值：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface NumberArray &#123;</span><br><span class="line">  readonly [index:number]:number</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> nnArr:NumberArray</span><br><span class="line">nnArr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">nnArr[<span class="number">5</span>] = <span class="number">26</span></span><br></pre></td></tr></table></figure><h3 id="类类型接口定义"><a href="#类类型接口定义" class="headerlink" title="类类型接口定义"></a>类类型接口定义</h3><p>类接口定义包括：<code>静态部分类型</code>和<code>动态部分类型</code>；构造器方法constructor属于<code>静态部分</code>。所以下面用<br>构造器签名去定义一个接口并试图定义一个类去实现这个接口时会报错误：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface ClockConstructor &#123;</span><br><span class="line">  <span class="keyword">new</span> (hour: number, <span class="attr">minute</span>: number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="title">implements</span> <span class="title">ClockConstructor</span> </span>&#123;<span class="comment">//报错</span></span><br><span class="line">  currentTime: <span class="built_in">Date</span>;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="我们应该直接操作类的静态部分"><a href="#我们应该直接操作类的静态部分" class="headerlink" title="我们应该直接操作类的静态部分"></a>我们应该直接操作类的静态部分</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">interface ClockConstructor &#123;</span><br><span class="line">  <span class="keyword">new</span> (hour:number,<span class="attr">minute</span>:number) : ClockInterface;</span><br><span class="line">&#125;</span><br><span class="line">interface ClockInterface &#123;</span><br><span class="line">  tick();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createClock</span>(<span class="params">ctor:ClockConstructor,hour:number,minute:number</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ctor(hour,minute);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClockOne</span> <span class="title">implements</span> <span class="title">ClockInterface</span> </span>&#123;</span><br><span class="line">  tick()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bibibi....'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClockTwo</span> <span class="title">implements</span> <span class="title">ClockInterface</span> </span>&#123;</span><br><span class="line">  tick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'dingding...'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> one = createClock(ClockOne, <span class="number">12</span>,<span class="number">38</span>);</span><br><span class="line"><span class="keyword">let</span> two = createClock(ClockTwo, <span class="number">12</span>,<span class="number">30</span>);</span><br></pre></td></tr></table></figure><h3 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">interface Shape &#123;</span><br><span class="line">    color: string;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">interface PenStroke &#123;</span><br><span class="line">    penWidth: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Square extends Shape, PenStroke &#123;</span><br><span class="line">    sideLength: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bb</span> <span class="title">implements</span> <span class="title">Square</span> </span>&#123;</span><br><span class="line">  sideLength = <span class="number">23</span></span><br><span class="line">  penWidth = <span class="number">23</span></span><br><span class="line">  color = <span class="string">'11'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span>  square = <span class="xml"><span class="tag">&lt;<span class="name">Square</span>&gt;</span>&#123;&#125;;</span></span><br><span class="line"><span class="xml">console.log(square);</span></span><br></pre></td></tr></table></figure><h3 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h3><p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Control</span> </span>&#123;</span><br><span class="line">  private name:any</span><br><span class="line">&#125;</span><br><span class="line">interface SelectableControl extends Control &#123;</span><br><span class="line">  select():<span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ButtonText</span> <span class="keyword">extends</span> <span class="title">Control</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Select</span> <span class="keyword">extends</span> <span class="title">Control</span> <span class="title">implements</span> <span class="title">SelectableControl</span></span>&#123;</span><br><span class="line">  select() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//// 错误：“Select2”类型缺少“name”属性。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Select2</span>  <span class="title">implements</span> <span class="title">SelectableControl</span></span>&#123;</span><br><span class="line">  select() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Typescript学习笔记-接口&quot;&gt;&lt;a href=&quot;#Typescript学习笔记-接口&quot; class=&quot;headerlink&quot; title=&quot;Typescript学习笔记-接口&quot;&gt;&lt;/a&gt;Typescript学习笔记-接口&lt;/h3&gt;&lt;p&gt;目标:&lt;br&gt;
    
    </summary>
    
    
      <category term="typescript" scheme="http://jekion.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>入门Nginx--学习笔记</title>
    <link href="http://jekion.com/2018/05/28/nginx_note1/"/>
    <id>http://jekion.com/2018/05/28/nginx_note1/</id>
    <published>2018-05-27T22:12:00.000Z</published>
    <updated>2019-06-08T23:40:34.267Z</updated>
    
    <content type="html"><![CDATA[<h3 id="入门Nginx–学习笔记"><a href="#入门Nginx–学习笔记" class="headerlink" title="入门Nginx–学习笔记"></a>入门Nginx–学习笔记</h3><p>目标:学会<code>nginx</code>的编译安装及添加模块，及以基本的配置；常用指令。<br><a id="more"></a></p><h4 id="虚拟服务器"><a href="#虚拟服务器" class="headerlink" title="虚拟服务器"></a>虚拟服务器</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.jekion.com *.jekion.com;</span><br><span class="line">        access_log E:\youngsunBook\_book\access_log.log combined;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   E:\youngsunBook\_book;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Nginx-启动，关闭，平滑重启"><a href="#Nginx-启动，关闭，平滑重启" class="headerlink" title="Nginx 启动，关闭，平滑重启"></a>Nginx 启动，关闭，平滑重启</h4><p>1)从容的停止Nginx</p><blockquote><p>kill -QUIT Nginx主进程号</p><p>kill - QUIT ‘/usr/local/webserver/logs/nginx.pid’<br>2)快速停止Nginx<br>kill -TERM Nginx主进程号</p><p>kill -TERM ‘…./ngnix.pid’</p><p>kill -INT Nginx主进程号</p><p>kill -INT ‘…/nginx.pid’</p></blockquote><p>3)强制停止所有Nginx进程</p><blockquote><p>pkill -9 nginx</p></blockquote><h5 id="nginx的平滑重启"><a href="#nginx的平滑重启" class="headerlink" title="nginx的平滑重启"></a>nginx的平滑重启</h5><p>当Nginx配置文件（nginx.conf）改变时，想重启nginx我们可以如下操作：<br>测试配置文件的正确性，</p><blockquote><p>nginx -t -c /usr/local/webserver/nginx/conf/nginx.conf</p></blockquote><p>如果正确我们可以发送信息给nginx主进程的方式来进行：</p><blockquote><p>kill -HUP Nginx主进程号</p><p>kill -HUP ‘nginx pid 路径’</p></blockquote><h5 id="nginx-的信号控制"><a href="#nginx-的信号控制" class="headerlink" title="nginx 的信号控制"></a>nginx 的信号控制</h5><blockquote><p>TREM,INT 快速关闭<br><br>QUIT 从容关闭<br><br>HUP 平滑重启,重新加载配置文件<br><br>USR1 重新打开日志文件,在切割日志时用途较多<br><br>USR2 平滑升级可执行<br><br>WINCH 从容关闭工作进程<br></p><h4 id="日志配置及分割"><a href="#日志配置及分割" class="headerlink" title="日志配置及分割"></a>日志配置及分割</h4><p>nginx中与日志相关的指令有两条：</p><p>log_format —日志格式方式 <br><br>access_log —日志存在目录</p></blockquote><p>log_format 格式如下：</p><blockquote><p>log_format name format [format …]</p></blockquote><p>ps:log_format指令设置的name名称在Nginx配置文件中是不能重复的。</p><p><code>log_format</code> 有一默认的无须设置的<code>combined</code>日志格式设置，如下:</p><blockquote><p>log_format combined ‘$remote_addr - $remote_user [$time_local] ‘<br> ‘“$request” $status $body_bytes_sent’<br> ‘“$http_referer” “$http_user_agent”‘</p></blockquote><p> 格式实例如下:</p><blockquote><p>127.0.0.1 - - [13/Jul/2018:06:34:05 +0800] “GET /gitbook/images/favicon.ico HTTP/1.1” 200 4286 “<a href="http://bbb.jekion.com/" target="_blank" rel="noopener">http://bbb.jekion.com/</a>“ “Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36”</p></blockquote><p>我们知道如果用nginx作为web服务器，位于负载均衡设备，Squid,反向代理之后；我们是获取不了用户实际ip地址的；因为中间加了一层，<code>$remote_addr</code>取到的是中层间的ip；</p><p>解决方法：反向代理服务器在转发请求的HTTP头信息中，可以增加<code>X-Forwarded-For</code>信息，用户记录原有的客户端Ip地址和原来客户端请求的服务器地址再用<code>$http_x_forwarded_for</code>变量取的。</p><blockquote><p>log_format mylogformat ‘$http_x_forwarded_for - …..’</p></blockquote><p>access_log格式如下:</p><blockquote><p>access_log path [format [buffer=size | off]]</p></blockquote><p>其中：</p><blockquote><p>path 指日志文件存在路径，format表示使用 log_format指令日志格式名称；buffer=size表示设置内存缓冲区的大小，buffer=32k</p></blockquote><p>(1)如果不想记录日志，可以使用以下指令关闭日志记录:</p><blockquote><p>access_log off;</p></blockquote><h4 id="Nginx压缩输出"><a href="#Nginx压缩输出" class="headerlink" title="Nginx压缩输出"></a>Nginx压缩输出</h4><p>压缩输出的相关指令位于http { … }两个大括号之间：</p><blockquote><p>#开启gzip模块 <br><br>gzip on;<br></p><p>#<br><br>gzip_min_length 1k;<br><br>gzip_buffers 4 16k;<br><br>gzip_http_version 1.1;<br><br>gzip_comp_level 2;<br><br>gzip_types text/html text/plain application/x-javascript text/css applicaiton/xml;<br><br>gzip_vary on;</p></blockquote><h4 id="Nginx-自动列目录配置"><a href="#Nginx-自动列目录配置" class="headerlink" title="Nginx 自动列目录配置"></a>Nginx 自动列目录配置</h4><p>前提条件是目录下不存在用index指令设置的默认首页文件。然后加下以下指令。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    autoindex on;</span><br><span class="line">    #设定索引时文件大小的单位（B/KB/MB/GB/）</span><br><span class="line">    autoindex_exact_size [on|off];</span><br><span class="line">    #开启以本地时间来显示文件时间的功能</span><br><span class="line">    autoindex_localtime [on|off];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Nginx的浏览器本地缓存设置"><a href="#Nginx的浏览器本地缓存设置" class="headerlink" title="Nginx的浏览器本地缓存设置"></a>Nginx的浏览器本地缓存设置</h4><blockquote><p>expires [time|epoch|max|off] <br><br><code>time</code> 为一个数值，默认单位为秒 如： expires 20 ，expires 30d | 1h<br><br><code>epoch</code> expires的值为 1 January 1970,00:00:01 GMT<br><br><code>max</code> expires的值为当前时间+10年；<br><br><code>-1</code>即永远过期。<br><br><code>off</code>表示不修改。</p></blockquote><p>对指定格式的文件进行缓存设置:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$</span><br><span class="line">&#123;</span><br><span class="line">    expires 30d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>expires</code>默认值<code>off</code>,作用域:http,server,localtion</p><h3 id="Nginx的Rewrite规则"><a href="#Nginx的Rewrite规则" class="headerlink" title="Nginx的Rewrite规则"></a>Nginx的Rewrite规则</h3><p>Rewrite主要的功能就是实现URL的重写，Nginx的Rewrite规则采用PCRE Perl兼容正则表达式的语法进行规则匹配，如果您需要Nginx的Rewrite功能，在编译Nginx之前，须要编译安装PCRE库。</p><p>Nginx Rewrite规则相关指令有<code>if,rewrite,set,return,break</code>等；</p><h4 id="break指令："><a href="#break指令：" class="headerlink" title="break指令："></a>break指令：</h4><p>该指令的作用是完成当前的规则集，不再处理rewrite指令。<br>使用环境：server,location,if</p><p>如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if($slow) &#123;</span><br><span class="line">    limit_rate 10k;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="if指令："><a href="#if指令：" class="headerlink" title="if指令："></a>if指令：</h4><p>if指令不支持嵌套，不支持多个条件<code>&amp;&amp;</code>和<code>||</code>处理;<br>使用环境：<code>server</code> <code>location</code></p><p>以下信息可以被指定为条件：<br>（1）变量名，错误的值包括：空字符串“”，或者任何以0开始的字符串；<br><br>（2）变量比较可以使用 <code>=</code>和<code>!=</code>运算符；<br><br>（3）正则表达式模式匹配可以使用<code>~*</code>(表示不区分大小定匹配)和<code>~</code>（表示区分大小定字母匹配）<br><br>（4）<code>!~</code>和<code>!~*</code>和<code>~</code>,<code>~*</code>相反，表示不匹配。<br><br>（5）<code>-f</code>和<code>!-f</code> 用来判断文件是否存在。<br><br>（6）<code>-d</code>和<code>!-d</code> 用来判断目录是否存在。<br><br>（7）<code>-e</code>和<code>!-e</code> 用来判断文件或目录是否存在。<br><br>（8）<code>-x</code>和<code>!-x</code> 用来判断文件是否可执行。<br><br>（9）<code>$1到$9</code>可以访问正则表示匹配组。</p><p>示例：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if($http_user_agent ~ MSIE) &#123;</span><br><span class="line">    rewrite ^(.*)$ /msie/$1 break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if($http_cookie ~* "id=([^;] +)(?:;|$)" ) &#123;</span><br><span class="line">    set $id $1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="return-指令"><a href="#return-指令" class="headerlink" title="return 指令"></a>return 指令</h4><p>使用环境:<code>server</code>,<code>location</code>,<code>if</code> <br><br>该指令用于结束规则的执行并返回状态给客户端。状态码可以使用这些值：204，400，402-406，408，410，413，416及500-504；此外非标准状态码444（将以不发送任何Header关的方式结束连接）。<br>示例：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*\.(sh|bash)?$ </span><br><span class="line">&#123;</span><br><span class="line">    return 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="rewrite-指令"><a href="#rewrite-指令" class="headerlink" title="rewrite 指令"></a>rewrite 指令</h4><p>语法： rewrite regex replacement flag <br><br>使用环境：<code>server</code>,<code>location</code>,<code>if</code><br><br>该指令根据表达式来重定向URL，或者修改字符串。指令根据配置文件中的顺序来执行。注意重写表达式只对相对路径有效。如果你配对主机名，你应该使用if语句。</p><p>rewrite 指令的最后一项参数为 <code>flag</code>标记，表示完成rewrite:</p><blockquote><p><code>last</code> —-相当于Apache里的L标记，表示完成rewrite;<br><code>break</code> —-本条规则匹配完成后，终止匹配，不再匹配后面的规则；<br><br><code>redirect</code> —- 返回302临时重定向，浏览器地址栏会显示跳转后的url地址。<br><br><code>permanent</code> —-返回301永久重定向，浏览器地址栏会显示跳转后的URL地址。</p></blockquote><h4 id="Ngnix-Rewrite-可用到的全局变量"><a href="#Ngnix-Rewrite-可用到的全局变量" class="headerlink" title="Ngnix Rewrite 可用到的全局变量"></a>Ngnix Rewrite 可用到的全局变量</h4><p>在<code>if</code>,<code>location</code>,<code>rewrite</code> 指令中，可以使用以下全局变量：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$args </span><br><span class="line">$content_length </span><br><span class="line">$content_type </span><br><span class="line">$document_root </span><br><span class="line">$document_uri </span><br><span class="line">$host</span><br><span class="line">$http_user_agent</span><br><span class="line">$http_cookie</span><br><span class="line">$limit_rate</span><br><span class="line">$request_body_file</span><br><span class="line">$request_method</span><br><span class="line">$remote_addr</span><br><span class="line">$remote_port</span><br><span class="line">$remote_user</span><br><span class="line">$request_filename</span><br><span class="line">$request_uri</span><br><span class="line">$query_string</span><br><span class="line">$scheme</span><br><span class="line">$server_addr</span><br><span class="line">$server_name</span><br><span class="line">$server_port</span><br><span class="line">$uri</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;入门Nginx–学习笔记&quot;&gt;&lt;a href=&quot;#入门Nginx–学习笔记&quot; class=&quot;headerlink&quot; title=&quot;入门Nginx–学习笔记&quot;&gt;&lt;/a&gt;入门Nginx–学习笔记&lt;/h3&gt;&lt;p&gt;目标:学会&lt;code&gt;nginx&lt;/code&gt;的编译安装及添加模块，及以基本的配置；常用指令。&lt;br&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://jekion.com/tags/linux/"/>
    
      <category term="nginx" scheme="http://jekion.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>LINUX笔记5-VI编辑器</title>
    <link href="http://jekion.com/2017/07/12/linux_note_5/"/>
    <id>http://jekion.com/2017/07/12/linux_note_5/</id>
    <published>2017-07-12T13:15:26.000Z</published>
    <updated>2019-06-06T23:21:04.534Z</updated>
    
    <content type="html"><![CDATA[<p>基本上    vi    共分为三种模式,分别是“一般指令模式”、“编辑模式”与“命令行命令模式”。</p><ul><li><p>一般指令模式；<br>vi    打开一个文件就直接进入一般指令模式了(这是默认的模式,也简称为一般模式)。在这个模式中,<br>你可以使用“上下左右”按键来移动光标,你可以使用“删除字符”或“删除整列”来处理文件内容,    也可以使用“复制、贴上”来处理你的文件数据。</p><a id="more"></a></li><li><p>编辑模式</p></li></ul><p>按下“i,    I,o,O,a,A,r,R”等任何一个字母之后才会进入编辑模式。</p><ul><li>命令行命令模式</li></ul><p>在一般模式当中,输入“    :    /    ?    ”三个中的任何一个按钮,就可以将光标移动到最下面那一列;打开命令模式。</p><h5 id="一般指令模式下常用热键说明："><a href="#一般指令模式下常用热键说明：" class="headerlink" title="一般指令模式下常用热键说明："></a>一般指令模式下常用热键说明：</h5><table><thead><tr><th>热键</th><th>说明</th></tr></thead><tbody><tr><td>[Ctrl]    +    [f]</td><td>屏幕“向下”移动一页,相当于    [Page    Down]按键</td></tr><tr><td>[Ctrl]    +    [b]</td><td>屏幕“向上”移动一页,相当于    [Page    Up]    按键</td></tr><tr><td>hjkl/←↓↑→</td><td>光标向不同方向移动一个字符（30j/↓向下移动30列）</td></tr><tr><td>GG/nG/gg</td><td>移动到最后/指定的n/第一列</td></tr><tr><td>$    或功能键[End]</td><td>移动到这一列的最后面字符处</td></tr><tr><td>n (enter)</td><td>n    为数字。光标向下移动    n    列</td></tr><tr><td>/word</td><td>向光标之下寻找一个名称为    word    的字串。</td></tr><tr><td>?word</td><td>向光标之上寻找一个名称为    word    的字串。</td></tr><tr><td>n</td><td>这个    n    是英文按键。代表“<u>重复前一个搜寻的动作</u>”。举例来说,    如果刚刚我们执行    /vbird    去向下搜寻    vbird    这个字串,则按下n    后,会向下继续搜寻下一个名称为    vbird    的字串。如果是执行    ?vbird    的话,那么按下    n则会向上继续搜寻名称为    vbird    的字串!</td></tr><tr><td>:n1,n2s/word1/word2/g</td><td>n1与n2为数字。在第n1与    n2列之间寻找word1    这个字串,并将该字串取代为    word2!</td></tr><tr><td>:1,$s/word1/word2/g</td><td>在第一列到最后一列之间寻找word1    这个字串,并将该字串取代为    word2!</td></tr><tr><td>:1,$s/word1/word2/gc</td><td>在第一列到最后一列之间寻找word1    这个字串,并将该字串取代为    word2!替换时进行询问</td></tr><tr><td>x,    X</td><td>在一列字当中,x    为向后删除一个字符    (相当于    [del]    按键),    X    为向前删除一个字符(相当于    [backspace]    亦即是倒退键)</td></tr><tr><td>dd</td><td>删除光标所在的那一整列</td></tr><tr><td>ndd</td><td>n为数字。删除光标所在的向下n列,例如20dd则是删除20列</td></tr><tr><td>yy</td><td>复制光标所在的那一列</td></tr><tr><td>nyy</td><td>复制光标所在的向下n列 n为数字</td></tr><tr><td>p/P</td><td>在光标所在列之下/上粘贴</td></tr><tr><td>u</td><td>撤消前一个动作。</td></tr><tr><td>.</td><td>重复前一个动作。</td></tr></tbody></table><h5 id="进入编辑模式常用热键说明："><a href="#进入编辑模式常用热键说明：" class="headerlink" title="进入编辑模式常用热键说明："></a>进入编辑模式常用热键说明：</h5><table><thead><tr><th>热键</th><th>说明</th></tr></thead><tbody><tr><td>i,I</td><td>进入插入模式(Insert    mode):i为“从目前光标所在处插入”,    I为“在目前所在列的第一个非空白字符处开始插入”。</td></tr><tr><td>a,A</td><td>进入插入模式(Insert    mode):a为“从目前光标所在的下一个字符处开始插入”,    A    为“从光标所在列的最后一个字符处开始插入”。</td></tr><tr><td>o,O</td><td>进入插入模式(Insert    mode):这是英文字母    o    的大小写。o为“在目前光标所在的下一列处插入新的一列”;    O    为在目前光标所在处的上一列插入新的一列!</td></tr><tr><td>r,R</td><td>进入取代模式(Replacemode):r    只会取代光标所在的那一个字符一次;R会一直取代光标所在的文字,直到按下    ESC    为止;</td></tr></tbody></table><h5 id="命令模式常用指令说明："><a href="#命令模式常用指令说明：" class="headerlink" title="命令模式常用指令说明："></a>命令模式常用指令说明：</h5><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>:w</td><td>将编辑的数据写入硬盘文件中</td></tr><tr><td>:q</td><td>离开vi</td></tr><tr><td>:wq</td><td>储存后离开,若为    :wq!    则为强制储存后离开</td></tr><tr><td>:n1,n2    w    [filename]</td><td>将    n1    到    n2    的内容储存成    filename    这个文件。</td></tr><tr><td>:set    nu/:set    nonu</td><td>显示/取消行号</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基本上    vi    共分为三种模式,分别是“一般指令模式”、“编辑模式”与“命令行命令模式”。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一般指令模式；&lt;br&gt;vi    打开一个文件就直接进入一般指令模式了(这是默认的模式,也简称为一般模式)。在这个模式中,&lt;br&gt;你可以使用“上下左右”按键来移动光标,你可以使用“删除字符”或“删除整列”来处理文件内容,    也可以使用“复制、贴上”来处理你的文件数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://jekion.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>LINUX笔记4-Linux系统中常见的压缩指令</title>
    <link href="http://jekion.com/2017/06/10/linux_note_4/"/>
    <id>http://jekion.com/2017/06/10/linux_note_4/</id>
    <published>2017-06-10T12:25:26.000Z</published>
    <updated>2019-06-06T23:21:04.503Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux的环境中,压缩文件的扩展名大多是:<code>.tar,.tar.gz,.tgz,.gz,.Z,.bz2,    *.xz</code><br><a id="more"></a></p><blockquote><p><em>.Z                    compress    程序压缩的文件;</em>.zip                    zip    程序压缩的文件;<br><em>.gz                    gzip    程序压缩的文件;</em>.bz2                    bzip2    程序压缩的文件;<br><em>.xz                    xz    程序压缩的文件;</em>.tar                    tar    程序打包的数据,并没有压缩过;<br><em>.tar.gz            tar    程序打包的文件,其中并且经过    gzip    的压缩</em>.tar.bz2            tar    程序打包的文件,其中并且经过    bzip2    的压缩<br>*.tar.xz            tar    程序打包的文件,其中并且经过    xz    的压缩</p></blockquote><h5 id="gzip命令使用："><a href="#gzip命令使用：" class="headerlink" title="gzip命令使用："></a><code>gzip</code>命令使用：</h5><blockquote><p>dmtsai@study    ~]$    gzip    [-cdtv#]    文件名<br>选项与参数:<br>-c        :将压缩的数据输出到屏幕上,可通过数据流重导向来处理;<br>-d        :解压缩;<br>-t        :可以用来检验一个压缩文件的一致性~看看文件有无错误;<br>-v        :可以显示出原文件/压缩文件的压缩比等信息;<br>-#        :#    为数字的意思,代表压缩等级,-1    最快,但是压缩比最差、-9    最慢,但是压缩比最好!默认是    -6</p></blockquote><p>注意：当你使用    gzip    进行压缩时,在默认的状态下原本的文件会被压缩成为    .gz    的文件名,原始文件就不再存在了。    </p><p>要压缩保留原文件可以使用如下指令：<br><code>gzip -9 -c services &gt; services.gz</code></p><p><code>cat/more/less</code>可以使用不同的方式来读取纯文本文件,<br><code>zcat/zmore/zless</code>则可以对应于cat/more/less    的方式来读取纯文本文件被压缩后的压缩文件!<br>由于<code>gzip</code>这个压缩指令主要想要用来取代<code>compress</code>的,所以不但<code>compress</code>的压缩文件可以使用<code>gzip</code>来解开,同时<code>zcat</code>这个指令可以同时读取<code>compress</code>与    <code>gzip</code>的压缩文件呦!<br>另外,如果你还想要从文字压缩文件当中找数据的话,可以通过<code>egrep</code>来搜寻关键字喔!而<br>不需要将压缩文件解开才以<code>grep</code>进行!    这对查询备份中的文本文件数据相当有用!</p><h5 id="bzip2命令使用"><a href="#bzip2命令使用" class="headerlink" title="bzip2命令使用:"></a><code>bzip2</code>命令使用:</h5><p>若说<code>gzip</code>是为了取代<code>compress</code>并提供更好的压缩比而成立的,那么<code>bzip2</code>则是为了取代<code>gzip</code>并提供更佳的压缩比而来的。用法与<code>gzip</code>几乎相同。</p><blockquote><p>   [dmtsai@study    ~]$    bzip2    [-cdkzv#]    文件名<br>选项与参数:<br>-c        :将压缩的过程产生的数据输出到屏幕上!<br>-d        :解压缩的参数<br>-k        :保留原始文件,而不会删除原始的文件喔!<br>-z        :压缩的参数    (默认值,可以不加)<br>-v        :可以显示出原文件/压缩文件的压缩比等信息;<br>-#        :与    gzip    同样的,都是在计算压缩比的参数,    -9    最佳,    -1    最快!</p></blockquote><p>相对应的有：<code>bzcat/bzmore/bzless/bzgrep</code>命令对压缩文件进行显示与查找。</p><h5 id="xz命令使用："><a href="#xz命令使用：" class="headerlink" title="xz命令使用："></a><code>xz</code>命令使用：</h5><p>虽然<code>bzip2</code>已经具有很棒的压缩比,不过显然某些自由软件开发者还不满足,因此后来还推出了<code>xz</code>这个压缩比更高的软件!同样相对应的有：<code>xzcat/xzmore/xzless/xzgrep</code>命令对压缩文件进行显示与查找。</p><p>PS：这三个压缩指令的压缩比例一个比一个好，但所花的时候也成正比；我们可以通过：<code>time xz -c 文件 &gt; 文件.xz</code> 来观查所用时间。</p><h4 id="打包指令：tar"><a href="#打包指令：tar" class="headerlink" title="打包指令：tar"></a>打包指令：<code>tar</code></h4><p>虽然<code>gzip,bzip2,xz</code>    也能够针对目录来进行压缩,不过对目录的压缩指的是“将目录内的所有文件”分别”进行压缩”的动作!而不像在Windows的系统,可以使用类似    WinRAR这一类的压缩软件来将好多数据“包成一个文件”的样式。所以Linux下面对多个目录或文件打包，需要用到 <code>tar</code>指令。</p><blockquote><p>[dmtsai@study    ~]$    tar    [-z,-j,-J]    [cv]    [-f    待创建的新文件名]    filename…    &lt;==打包与压缩<br>[dmtsai@study    ~]$    tar    [-z,-j,-J]    [tv]    [-f    既有的    tar文件名]                                                    &lt;==察看文件名<br>[dmtsai@study    ~]$    tar    [-z,-j,-J]    [xv]    [-f    既有的    tar文件名]    [-C    目录]            &lt;==解压缩<br>选项与参数:<br>-c        :创建打包文件,可搭配    -v    来察看过程中被打包的文件名(filename)<br>-t        :察看打包文件的内容含有哪些文件名,重点在察看“文件名”就是了;<br>-x        :解打包或解压缩的功能,可以搭配    -C    (大写)    在特定目录解开<br>                        特别留意的是,    -c,    -t,    -x    不可同时出现在一串命令行中。<br>-z        :通过    gzip        的支持进行压缩/解压缩:此时文件名最好为    <em>.tar.gz<br>-j        :通过    bzip2    的支持进行压缩/解压缩:此时文件名最好为    </em>.tar.bz2<br>-J        :通过    xz                的支持进行压缩/解压缩:此时文件名最好为    *.tar.xz<br>                        特别留意,    -z,    -j,    -J    不可以同时出现在一串命令行中<br>-v        :在压缩/解压缩的过程中,将正在处理的文件名显示出来!<br>-f    filename:-f    后面要立刻接要被处理的文件名!建议    -f    单独写一个选项啰!(比较不会忘记)<br>-C    目录                :这个选项用在解压缩,若要在特定目录解压缩,可以使用这个选项。<br>其他后续练习会使用到的选项介绍:<br>-p(小写)    :保留备份数据的原本权限与属性,常用于备份(-c)重要的配置文件<br>-P(大写)    :保留绝对路径,亦即允许备份数据中含有根目录存在之意;<br>–exclude=FILE:在压缩的过程中,不要将    FILE    打包!</p></blockquote><p>常用：</p><ul><li><code>tar -j -cv -f xxx.tar.bz2 ./xxx</code>压缩打包<code>xxx</code> 目录; </li><li><code>tar -j -xv -f xxx.tar.bz2</code>解压缩打包文件; </li><li><code>tar -tv -f xxx.tar.bz2 ./xxx</code>查看打包文件;</li><li><code>tar -j xv -f xxx.tar.bz2 -C /tmp</code> 解压<code>xxx.tar.bz2</code> 至 <code>/tmp</code> </li></ul><h5 id="提取部分文件"><a href="#提取部分文件" class="headerlink" title="提取部分文件"></a>提取部分文件</h5><p>1、先搜索：<br><code>tar -j tf -f xxx.tar.bz2 | grep &#39;xxxx&#39;</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Linux的环境中,压缩文件的扩展名大多是:&lt;code&gt;.tar,.tar.gz,.tgz,.gz,.Z,.bz2,    *.xz&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://jekion.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>LINUX笔记3-磁盘的分区，格式化，挂载</title>
    <link href="http://jekion.com/2017/06/02/linux_note_3/"/>
    <id>http://jekion.com/2017/06/02/linux_note_3/</id>
    <published>2017-06-02T05:21:23.000Z</published>
    <updated>2019-06-06T23:21:04.472Z</updated>
    
    <content type="html"><![CDATA[<h5 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h5><blockquote><p>[root@study    ~]#    mount    -a<br>[root@study    ~]#    mount    [-l]<br>[root@study    ~]#    mount    [-t    文件系统]    LABEL=’’        挂载点<br>[root@study    ~]#    mount    [-t    文件系统]    UUID=’’            挂载点        #    鸟哥近期建议用这种方式喔!<br>[root@study    ~]#    mount    [-t    文件系统]    设备文件名        挂载点<br><a id="more"></a><br>选项与参数:<br>-a:依照配置文件    <code>/etc/fstab</code>的数据将所有未挂载的磁盘都挂载上来<br>-l:单纯的输入    mount    会显示目前挂载的信息。加上    -l    可增列    Label    名称!<br>-t:可以加上文件系统种类来指定欲挂载的类型。常见的    Linux    支持类型有:xfs,    ext3,    ext4,reiserfs,    vfat,    iso9660(光盘格式),    nfs,    cifs,    smbfs    (后三种为网络文件系统类型)<br>-n:在默认的情况下,系统会将实际挂载的情况实时写入    /etc/mtab    中,以利其他程序的运行。但在某些情况下(例如单人维护模式)为了避免问题会刻意不写入。此时就得要使用    -n    选项。<br>-o:后面可以接一些挂载时额外加上的参数!比方说帐号、密码、读写权限等:<br>async,    sync:此文件系统是否使用同步写入    (sync)    或非同步    (async)    的内存机制,请参考文件系统运行方式。默认为    async。<br>atime,noatime:    是否修订文件的读取时间(atime)。为了性能,某些时刻可使用    noatime<br>ro,    rw:        挂载文件系统成为只读(ro)    或可读写(rw)<br>auto,    noauto:        允许此    filesystem    被以    mount    -a    自动挂载(auto)<br>dev,    nodev:                是否允许此    filesystem    上,可创建设备文件?    dev    为可允许<br>suid,    nosuid:        是否允许此    filesystem    含有    suid/sgid    的文件格式?<br>exec,    noexec:        是否允许此    filesystem    上拥有可执行    binary    文件?<br>user,    nouser:        是否允许此    filesystem    让任何使用者执行    mount    ?一般来说,mount    仅有    root    可以进行,但下达    user    参数,则可让一般    user    也能够对此    partition    进行    mount    。</p></blockquote><p>defaults:默认值为:rw,    suid,    dev,    exec,    auto,    nouser,    and    async<br>remount:                            重新挂载,这在系统出错,或重新更新参数时,很有用!</p><h4 id="設置开机挂载"><a href="#設置开机挂载" class="headerlink" title="設置开机挂载"></a>設置开机挂载</h4><p>1,更更文件<code>/etc/fstab</code> </p><blockquote><p>UUID=e0fa7252-b374-4a06-987a-3cb14f415488  /data/mnt  default  0  0 </p></blockquote><p>2,查看要挂载设备是否已经挂载，若挂载将其缷载。</p><blockquote><p>df //查看当前已经挂载的设备<br>umount /dev/vda4  //缷载设备</p></blockquote><p>3,测试是否挂载成功</p><blockquote><p>mount -a</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;文件属性&quot;&gt;&lt;a href=&quot;#文件属性&quot; class=&quot;headerlink&quot; title=&quot;文件属性&quot;&gt;&lt;/a&gt;文件属性&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;[root@study    ~]#    mount    -a&lt;br&gt;[root@study    ~]#    mount    [-l]&lt;br&gt;[root@study    ~]#    mount    [-t    文件系统]    LABEL=’’        挂载点&lt;br&gt;[root@study    ~]#    mount    [-t    文件系统]    UUID=’’            挂载点        #    鸟哥近期建议用这种方式喔!&lt;br&gt;[root@study    ~]#    mount    [-t    文件系统]    设备文件名        挂载点&lt;br&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://jekion.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>LINUX笔记2-文件权限与目录</title>
    <link href="http://jekion.com/2017/05/17/linux_note_2/"/>
    <id>http://jekion.com/2017/05/17/linux_note_2/</id>
    <published>2017-05-17T03:20:20.000Z</published>
    <updated>2019-06-06T23:21:04.441Z</updated>
    
    <content type="html"><![CDATA[<h5 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h5><p>我们可以利用<code>ls -al</code>来查看文件或目录的属性；执行后如下图：<br><a id="more"></a><br><img src="https://github.com/jqy518/linux-note/raw/master/imgs/5_3.png" alt="img1"></p><h5 id="文件类型与权限详解："><a href="#文件类型与权限详解：" class="headerlink" title="文件类型与权限详解："></a>文件类型与权限详解：</h5><p><img src="https://github.com/jqy518/linux-note/raw/master/imgs/5_2.png" alt="img2"></p><ul><li><p>第一个字符代表这个文件是“目录、文件或链接文件等等”:</p><blockquote><p>当为[    d    ]则是目录,例如上表文件名为“.config”的那一行;<br>当为[    -    ]则是文件,例如上表文件名为“initial-setup-ks.cfg”那一行;<br>若是[    l    ]则表示为链接文件(link    file);<br>若是[    b    ]则表示为设备文件里面的可供储存的周边设备(可随机存取设备);<br>若是[    c    ]则表示为设备文件里面的序列埠设备,例如键盘、鼠标(一次性读取设<br>备)。</p></blockquote></li><li><p>接下来的字符中,以三个为一组,且均为“rwx”    的三个参数的组合。</p><blockquote><p>[    r    ]代表可读(read)、<br>[    w    ]代表可写(write)、<br>[    x    ]代表可执行(execute)。<br>要注意的是,这三个权限的位置不会改变,如果没有权限,就会出现减号[    -    ]而已。</p></blockquote></li></ul><h5 id="chgrp-chown-chmod指令使用："><a href="#chgrp-chown-chmod指令使用：" class="headerlink" title="chgrp,chown chmod指令使用："></a><code>chgrp,chown chmod</code>指令使用：</h5><ul><li><p>chgrp:</p><blockquote><p>chgrp -R    users    ./data   //改变DATA文件夹的用户组，<br>-R :    进行递回(recursive)的持续变更,亦即连同次目录下的所有文件、目录<br>都更新成为这个群组之意。常常用在变更某一目录内所有的文件之情况。</p></blockquote></li><li><p>chown:</p><blockquote><p>chown    [-R]    帐号名称    文件或目录<br>chown    [-R]    帐号名称:群组名称    文件或目录<br>选项与参数:<br>-R    :    进行递回(recursive)的持续变更,亦即连同次目录下的所有文件都变更</p></blockquote></li></ul><p>例如：</p><blockquote><p>chown    zhangsan initial-setup-ks.cfg<br>chown root:root initial-setup-ks.cfg //把用户及群组都改回root</p></blockquote><ul><li>chmod:<br>修改文件或文件夹的权限，有两种形式的修改：一种是数字型，一种是字符型运算。</li></ul><p>1,数字型：</p><p>Linux文件的基本权限就有九个,分别是owner/group/others三种身份各有自己的read/write/execute权限:如：<code>-rwxr-xr-x</code> 其中分值如下:</p><blockquote><p>r:4    &gt;    w:2    &gt;    x:1</p></blockquote><p>如：</p><blockquote><p>chmod -R 755 ./data<br>//-R :进行递回(recursive)的持续变更,亦即连同次目录下的所有文件都会变更</p></blockquote><p>2,字符型运算：<br>基本上就九个权限分别是<br>(1)user    (2)group    (3)others三种身份啦!<br>那么我们就可以借由<code>u,g,o</code>来代表三种身份的权限!此外,<code>a</code>则代表all亦即全部的身份!<br>那么读写的权限就可以写成<code>r,w,x</code>;</p><p>例如：</p><blockquote><p>chmod u=rwx,go=rx .bashrc // 改变权限为<code>-rwxr-xr-x</code></p></blockquote><h5 id="文件与目录的权限意义："><a href="#文件与目录的权限意义：" class="headerlink" title="文件与目录的权限意义："></a>文件与目录的权限意义：</h5><p>1,权限字符对文件的意义：</p><blockquote><p>r    (read):可读取此一文件的实际内容,如读取文本文件的文字内容等;<br>w    (write):可以编辑、新增或者是修改该文件的内容(但不含删除该文件);<br>x    (eXecute):该文件具有可以被系统执行的权限。</p></blockquote><p>2,权限字符对目录的意义：</p><blockquote><p>r:<br>表示具有读取目录结构清单的权限,所以当你具有读取(r)一个目录的权限时,表示你可以查询该目录下的文件名数据。    所以你就可以利用    ls    这个指令将该目录的内容列表显示出来!<br>w:<br>这个可写入的权限对目录来说,是很了不起的!    因为他表示你具有异动该目录结构清单的权限,也就是下面这些权限:<br>1)创建新的文件与目录;<br>2)删除已经存在的文件与目录(不论该文件的权限为何!)<br>3)将已存在的文件或目录进行更名;<br>4)搬移该目录内的文件、目录位置。<br>总之,目录的w权限就与该目录下面的文件名异动有关就对了啦!<br>x:<br>目录的x代表的是使用者能否进入该目录成为工作目录。（利用 <code>cd</code>进入目录作为工作目录）</p></blockquote><h5 id="Linux目录配置："><a href="#Linux目录配置：" class="headerlink" title="Linux目录配置："></a>Linux目录配置：</h5><p>为了便于管理系统内的应用及文件；我们尽量遵循FHS的标准；来放置我们的软件及文件；<br><img src="https://github.com/jqy518/linux-note/raw/master/imgs/5_4.png" alt="img2"><br>几个比较重要的目录介绍：</p><blockquote><p><code>/bin</code> ： 系统有很多放置可执行文件的目录,但/bin比较特殊。因为/bin放置的是在单人维护模式下还能够被操作的指令。    在/bin下面的指令可以被root与一般帐号所使用,主要有:cat,    chmod,    chown,    date,    mv,    mkdir,    cp,    bash等等常用的指令。<br><code>/boot</code> :这个目录主要在放置开机会使用到的文件,包括Linux核心文件以及开机菜单与开机所需配置文件等等。    Linux    kernel常用的文件名为:vmlinuz,如果使用的是grub2这个开机管理程序,    则还会存在/boot/grub2/这个目录喔!<br><code>/dev</code> :在Linux系统上,任何设备与周边设备都是以文件的型态存在于这个目录当中的。    你只要通过存取这个目录下面的某个文件,就等于存取某个设备啰~    比要重要的文件有/dev/null,    /dev/zero,    /dev/tty,    /dev/loop,    /dev/sd等等<br><code>/etc</code> :系统主要的配置文件几乎都放置在这个目录内,例如人员的帐号密码档、各种服务的启始档等等。一般来说,这个目录下的各文件属性是可以让一般使用者查阅的,    但是只有root有权力修改。FHS建议不要放置可可执行文件(binary)在这个目录中喔。比较重要的文件有:    /etc/modprobe.d/,/etc/passwd,    /etc/fstab,    /etc/issue    等等。另外    FHS    还规范几个重要的目录最好要存在    /etc/    目录下喔:/etc/opt(必要):这个目录在放置第三方协力软件    /opt    的相关配置文件    /etc/X11/(建议):与    X    Window    有关的各种配置文件都在这里,尤其是    xorg.conf    这个    X    Server    的配置文件。    /etc/sgml/(建议):与    SGML    格式有关的各项配置文件    /etc/xml/(建议):与    XML格式有关的各项配置文件<br><code>/opt</code>:这个是给第三方协力软件放置的目录。什么是第三方协力软件啊?    举例来<br>说,KDE这个桌面管理系统是一个独立的计划,不过他可以安装到Linux系统中,因此KDE的软件就建议放置到此目录下了。    另外,如果你想要自行安装额外的软件(非原本的distribution提供的),那么也能够将你的软件安装到这里来。    不过,以前的Linux系统中,我们还是习惯放置在/usr/local目录下呢!<br><code>/srv</code> :srv可以视为“service”的缩写,是一些网络服务启动之后,这些服务所需要<br>取用的数据目录。    常见的服务例如WWW,    FTP等等。举例来说,WWW服务器需要的网页数据就可以放置在/srv/www/里面。    不过,系统的服务数据如果尚未要提供给网际网络任何人浏览的话,默认还是建议放置到    /var/lib下面即可。<br><code>/usr,/var</code>: 第二层FHS设置;</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;文件属性&quot;&gt;&lt;a href=&quot;#文件属性&quot; class=&quot;headerlink&quot; title=&quot;文件属性&quot;&gt;&lt;/a&gt;文件属性&lt;/h5&gt;&lt;p&gt;我们可以利用&lt;code&gt;ls -al&lt;/code&gt;来查看文件或目录的属性；执行后如下图：&lt;br&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://jekion.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>LINUX笔记1-常用指令使用</title>
    <link href="http://jekion.com/2017/05/15/linux_note_1/"/>
    <id>http://jekion.com/2017/05/15/linux_note_1/</id>
    <published>2017-05-15T07:20:20.000Z</published>
    <updated>2019-06-06T23:21:04.425Z</updated>
    
    <content type="html"><![CDATA[<h5 id="nano文本编辑器使用。"><a href="#nano文本编辑器使用。" class="headerlink" title="nano文本编辑器使用。"></a><code>nano</code>文本编辑器使用。</h5><blockquote><p>nano 11.txt<br>如果<code>11.txt</code>存在则打开，如果不存在则为新文件;<br><a id="more"></a><br><img src="https://github.com/jqy518/linux-note/raw/master/imgs/3_1.png" alt="nano"></p></blockquote><h5 id="代表Ctrl-M-代表alt"><a href="#代表Ctrl-M-代表alt" class="headerlink" title="^代表Ctrl;  M-代表alt"></a><code>^</code>代表<code>Ctrl</code>;  <code>M-</code>代表<code>alt</code></h5><h4 id="常用的关机命令："><a href="#常用的关机命令：" class="headerlink" title="常用的关机命令："></a>常用的关机命令：</h4><blockquote><p>将数据同步写入硬盘中的指令:    sync<br>惯用的关机指令:    shutdown<br>重新开机,关机:    reboot,    halt,    poweroff</p></blockquote><h4 id="cp-rm-mv-指令"><a href="#cp-rm-mv-指令" class="headerlink" title="cp,rm,mv 指令"></a>cp,rm,mv 指令</h4><ul><li><code>cp</code>指令：<blockquote><p>[root@study    ~]#    cp    [-adfilprsu]    来源文件(source)    目标文件(destination)<br>[root@study    ~]#    cp    [options]    source1    source2    source3    ….    directory<br>选项与参数:<br>-a ：相当于    -dr    –preserve=all    的意思,至于    dr    请参考下列说明;(常用)<br>-d ：若来源文件为链接文件的属性(link    file),则复制链接文件属性而非文件本身;<br>-f ：为强制(force)的意思,若目标文件已经存在且无法打开,则移除后再尝试一次;<br>-i ：若目标文件(destination)已经存在时,在覆盖时会先询问动作的进行(常用)<br>-l ：进行硬式链接(hard    link)的链接文件创建,而非复制文件本身;<br>-p ：连同文件的属性(权限、用户、时间)一起复制过去,而非使用默认属性(备份常用);<br>-r ：递回持续复制,用于目录的复制行为;(常用)<br>-s ：复制成为符号链接文件    (symbolic    link),亦即“捷径”文件;<br>-u ：destination    比    source    旧才更新    destination,或    destination    不存在的情况下才复制。<br>–preserve=all    :除了    -p    的权限相关参数外,还加入    SELinux    的属性,    links,    xattr    等也复制了。<br>最后需要注意的,如果来源文件有两个以上,则最后一个目的文件一定要是“目录”才行!</p></blockquote></li></ul><p>常用练习：</p><blockquote><p><code>cp /usr/src/bb.txt  ./ff.txt</code>  //复制 bb.txt并改名ff.txt<br><code>cp -r /usr/src /tmp</code> //复制目录到<code>/tmp</code><br><code>cp -r /usr/src/* /tmp/cpsrc</code> 复制目录/usr/src下的文件及目录到/tmp/cpsrc<br><code>cp -l ./rar/readme.txt ./readme_l.txt</code> 创建实体连接<br><code>cp -s ./rar/readme.txt ./readme_s.txt</code> 创建符号连接<br><code>cp -a /usr /bkusr</code> 备份/usr（保留相关属性,ps:由于普通用户身份并不能随意修改文件的拥有者与群组,因此虽然能够复制的相关权限与时间等属性,    但是与拥有者、群组相关的,普通用户身份无法进行的动作,即使加上    -a    选项,也是无法达成完整复制权限的!所以备份最好用<code>root</code>用户）</p></blockquote><ul><li>rm指令：<blockquote><p>选项与参数:<br>-f :就是    force    的意思,忽略不存在的文件,不会出现警告讯息;<br>-i :互动模式,在删除前会询问使用者是否动作<br>-r :递回删除啊!最常用在目录的删除了!这是非常危险的选项!!!</p></blockquote></li></ul><p>常用练习：</p><blockquote><p>rm -i aa.txt   //删除前询问<br>rm -r ./cc //删除目录<br>rm  ./-aa- 删除以‘-’开头的文件</p></blockquote><p>ps:<code>root</code>用户因身份特殊默认带有<code>-i</code>参数</p><ul><li>mv指令：</li></ul><blockquote><p>-f :force    强制的意思,如果目标文件已经存在,不会询问而直接覆盖;<br>-i :若目标文件    (destination)    已经存在时,就会询问是否覆盖!<br>-u :若目标文件已经存在,且    source    比较新,才会更新    (update)</p></blockquote><p>常用练习：</p><blockquote><p>mv aa.txt ./back   //将文件aa.txt移动到back文件中<br>mv aa.txt cc.txt //更改文件名称<br>mv ./back ./backup //更改文件夹名称。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;nano文本编辑器使用。&quot;&gt;&lt;a href=&quot;#nano文本编辑器使用。&quot; class=&quot;headerlink&quot; title=&quot;nano文本编辑器使用。&quot;&gt;&lt;/a&gt;&lt;code&gt;nano&lt;/code&gt;文本编辑器使用。&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;nano 11.txt&lt;br&gt;如果&lt;code&gt;11.txt&lt;/code&gt;存在则打开，如果不存在则为新文件;&lt;br&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://jekion.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux下使用supervisor后台运行你的应用</title>
    <link href="http://jekion.com/2017/05/03/supervisor/"/>
    <id>http://jekion.com/2017/05/03/supervisor/</id>
    <published>2017-05-03T02:10:59.000Z</published>
    <updated>2019-06-06T23:21:04.847Z</updated>
    
    <content type="html"><![CDATA[<p><code>redis</code>Supervisor是一个进程管理工具，当我们有应用需要以后台服务方式跑起来时，我们可以利用它进行管理。<br><a id="more"></a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>1) 利用<code>easy_install</code>安装</p><blockquote><p>easy_install supervisor<br>2) 也可以下载后手动安装<br><a href="https://pypi.python.org/pypi/supervisor/3.3.1" target="_blank" rel="noopener">supervisor-3.3.1.tar.gz</a><br>然后解压<code>tar xvf supervisor-3.3.1.tar.gz</code>进入根目录运行以下命令进行安装<br>python setup.py install </p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>1)生成配置文件,我们可以运行以下命令在相应目录下生成配置文件<br>echo_supervisord_conf &gt; /etc/supervisord.conf<br>进行以下配置<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[unix_http_server]</span><br><span class="line">file=<span class="regexp">/tmp/</span>supervisor.sock ; UNIX socket 文件，supervisorctl 会使用</span><br><span class="line">;chmod=<span class="number">0700</span> ; socket 文件的 mode，默认是 <span class="number">0700</span></span><br><span class="line">;chown=nobody:nogroup ; socket 文件的 owner，格式： uid:gid</span><br><span class="line"></span><br><span class="line">;[inet_http_server] ; HTTP 服务器，提供 web 管理界面</span><br><span class="line">;port=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9001</span> ; Web 管理后台运行的 IP 和端口，如果开放到公网，需要注意安全性</span><br><span class="line">;username=user ; 登录管理后台的用户名</span><br><span class="line">;password=<span class="number">123</span> ; 登录管理后台的密码</span><br><span class="line"></span><br><span class="line">[supervisord]</span><br><span class="line">logfile=<span class="regexp">/tmp/</span>supervisord.log ; 日志文件，默认是 $CWD/supervisord.log</span><br><span class="line">logfile_maxbytes=<span class="number">50</span>MB ; 日志文件大小，超出会 rotate，默认 <span class="number">50</span>MB</span><br><span class="line">logfile_backups=<span class="number">10</span> ; 日志文件保留备份数量默认 <span class="number">10</span></span><br><span class="line">loglevel=info ; 日志级别，默认 info，其它: debug,warn,trace</span><br><span class="line">pidfile=<span class="regexp">/tmp/</span>supervisord.pid ; pid 文件</span><br><span class="line">nodaemon=<span class="literal">false</span> ; 是否在前台启动，默认是 <span class="literal">false</span>，即以 daemon 的方式启动</span><br><span class="line">minfds=<span class="number">1024</span> ; 可以打开的文件描述符的最小值，默认 <span class="number">1024</span></span><br><span class="line">minprocs=<span class="number">200</span> ; 可以打开的进程数的最小值，默认 <span class="number">200</span></span><br><span class="line"></span><br><span class="line">; the below section must remain <span class="keyword">in</span> the config file <span class="keyword">for</span> RPC</span><br><span class="line">; (supervisorctl/web interface) to work, additional interfaces may be</span><br><span class="line">; added by defining them <span class="keyword">in</span> separate rpcinterface: sections</span><br><span class="line">[rpcinterface:supervisor]</span><br><span class="line">supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface</span><br><span class="line"></span><br><span class="line">[supervisorctl]</span><br><span class="line">serverurl=unix:<span class="comment">///tmp/supervisor.sock ; 通过 UNIX socket 连接 supervisord，路径与 unix_http_server 部分的 file 一致</span></span><br><span class="line">;serverurl=http:<span class="comment">//127.0.0.1:9001 ; 通过 HTTP 的方式连接 supervisord</span></span><br><span class="line"></span><br><span class="line">; 包含其他的配置文件</span><br><span class="line">[include]</span><br><span class="line">files = <span class="regexp">/etc/</span>supervisor<span class="comment">/*.conf ; 可以是 *.conf 或 *.ini</span></span><br></pre></td></tr></table></figure></p></blockquote><p>推荐将各个进程配置放到单独的文件中，然后通过[include]配置项引用；如上面配置最后一句，开启扫描的目录；以相应配置文件；</p><p>进程program配置，我们可以做为单独配置放在上面的包含路径下面.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[program:usercenter]</span><br><span class="line">directory = <span class="regexp">/home/</span>leon/projects/usercenter ; 程序的启动目录</span><br><span class="line">command = gunicorn -c gunicorn.py wsgi:app ; 启动命令，可以看出与手动在命令行启动的命令是一样的</span><br><span class="line">autostart = <span class="literal">true</span> ; 在 supervisord 启动的时候也自动启动</span><br><span class="line">startsecs = <span class="number">5</span> ; 启动 <span class="number">5</span> 秒后没有异常退出，就当作已经正常启动了</span><br><span class="line">autorestart = <span class="literal">true</span> ; 程序异常退出后自动重启</span><br><span class="line">startretries = <span class="number">3</span> ; 启动失败自动重试次数，默认是 <span class="number">3</span></span><br><span class="line">user = leon ; 用哪个用户启动</span><br><span class="line">redirect_stderr = <span class="literal">true</span> ; 把 stderr 重定向到 stdout，默认 <span class="literal">false</span></span><br><span class="line">stdout_logfile_maxbytes = <span class="number">20</span>MB ; stdout 日志文件大小，默认 <span class="number">50</span>MB</span><br><span class="line">stdout_logfile_backups = <span class="number">20</span> ; stdout 日志文件备份数</span><br><span class="line">; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）</span><br><span class="line">stdout_logfile = <span class="regexp">/data/</span>logs/usercenter_stdout.log</span><br><span class="line"></span><br><span class="line">; 可以通过 environment 来添加需要的环境变量，一种常见的用法是修改 PYTHONPATH</span><br><span class="line">; environment=PYTHONPATH=$PYTHONPATH:<span class="regexp">/path/</span>to/somewhere</span><br></pre></td></tr></table></figure></p><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><blockquote><p>supervisord -c supervisord.conf</p></blockquote><h4 id="配置需要后台启动的应用"><a href="#配置需要后台启动的应用" class="headerlink" title="配置需要后台启动的应用"></a>配置需要后台启动的应用</h4><p>如：<code>mongodb</code>,<code>express</code>web应用等我们都可以通过supervisor进行管理；作为后台运行；我们以mongodb为例；看下他的config文件<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[program:mongodb]</span><br><span class="line"></span><br><span class="line">command=<span class="regexp">/usr/</span>local/mongodb/bin/mongod -f /usr/local/mongodb/config.conf</span><br><span class="line"></span><br><span class="line">directory=<span class="regexp">/usr/</span>local/mongodb/bin/</span><br><span class="line"></span><br><span class="line">autorestart=<span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>保存上面配置作为一个文件<code>mongodb.conf</code>保存到我们的<code>include</code>文件夹下。再运行以下命令启动即可：</p><blockquote><p>supervisorctl start mongodb </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;redis&lt;/code&gt;Supervisor是一个进程管理工具，当我们有应用需要以后台服务方式跑起来时，我们可以利用它进行管理。&lt;br&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://jekion.com/tags/linux/"/>
    
      <category term="supervisor" scheme="http://jekion.com/tags/supervisor/"/>
    
  </entry>
  
  <entry>
    <title>nodejs中使用Redis</title>
    <link href="http://jekion.com/2017/04/26/node_redis/"/>
    <id>http://jekion.com/2017/04/26/node_redis/</id>
    <published>2017-04-26T10:10:59.000Z</published>
    <updated>2019-06-06T23:21:04.706Z</updated>
    
    <content type="html"><![CDATA[<p><code>redis</code>作为后端开发中常用缓存工具，相信大家对它应该不会陌生；那么nodejs中是不是也能使用redis呢，答案是肯定的，接下来<br>带大家熟习下node模块<code>redis</code>的使用；<br><a id="more"></a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="window下安装redis服务"><a href="#window下安装redis服务" class="headerlink" title="window下安装redis服务"></a>window下安装redis服务</h4><p>在安装模块之前，先得保证我们本地或都远程有安装redis；目前redis在linux下相对友好,安装起来也较window简单,window只支持64位系统。下面是版本的下载地址<a href="https://github.com/MSOpenTech/redis/releases" target="_blank" rel="noopener">https://github.com/MSOpenTech/redis/releases</a>;<br>我下载的是免安装版的解压后可以看到以下目录结构：<br><img src="/img/redis.jpg" alt="redis"><br>我们在当前目录的<code>cmd</code>窗口下执行以下命令开启redis服务</p><blockquote><p>—注册服务<br>  redis-server –service-install redis.windows.conf –loglevel verbose<br>  —开启服务<br>  redis-server –service-start<br>开启服务后我们可以运行<code>redis-cli.exe</code>客户端进行测试。</p></blockquote><h4 id="redis模块安装"><a href="#redis模块安装" class="headerlink" title="redis模块安装"></a>redis模块安装</h4><p>nodejs中redis模块安装使用很简单<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install redis --save</span><br></pre></td></tr></table></figure></p><p>使用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> redis = <span class="built_in">require</span>(<span class="string">"redis"</span>),</span><br><span class="line">    client = redis.createClient([options]);</span><br></pre></td></tr></table></figure></p><p><code>options</code>是一个可以客户连接进行配置的Object对象；相应的属性我们可以参数redis的api文档：<br><a href="https://www.npmjs.com/package/redis" target="_blank" rel="noopener">redis模块使用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;redis&lt;/code&gt;作为后端开发中常用缓存工具，相信大家对它应该不会陌生；那么nodejs中是不是也能使用redis呢，答案是肯定的，接下来&lt;br&gt;带大家熟习下node模块&lt;code&gt;redis&lt;/code&gt;的使用；&lt;br&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://jekion.com/tags/node/"/>
    
      <category term="redis" scheme="http://jekion.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>使用RegExp对象test(),exec()方法时注意&#39;g&#39;标志</title>
    <link href="http://jekion.com/2017/04/15/regexp/"/>
    <id>http://jekion.com/2017/04/15/regexp/</id>
    <published>2017-04-15T07:16:22.000Z</published>
    <updated>2019-06-06T23:21:04.800Z</updated>
    
    <content type="html"><![CDATA[<p>正则对象或字面量在加了’g’标志，进行全局匹配时，要注意test(),与exec()方法会更新RegExp.lastIndex的值。<br><a id="more"></a></p><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>当正则表达式使用 “g” 标志时，多次执行 exec()/test()来查找或检查同一个字符串时。下次操作将从正则表达式的  lastIndex 属性指定的位置开始；而exec()/test()方法会更新<code>RegExp.lastIndex</code>属性，换句话说，下次匹配会跳过之前已经匹配过的字符；当<code>lastIndex</code>为到了字符串末尾时，<br>lastIndex重置为0;如下代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/((13[0-9])|(14[5|7])|(15([0-3]|[5-9]))|(18[0,5-9]))\d&#123;8&#125;/g</span>;</span><br><span class="line"><span class="keyword">let</span> val = <span class="string">'13088889999'</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.test(value),regex.lastIndex); <span class="comment">//out: true 11</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.test(value),regex.lastIndex); <span class="comment">//out: false 0</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.test(value),regex.lastIndex); <span class="comment">//out: true 11</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.test(value),regex.lastIndex); <span class="comment">//out: false 0</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.test(value),regex.lastIndex); <span class="comment">//out: true 11</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.test(value),regex.lastIndex); <span class="comment">//out: false 0</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.test(value),regex.lastIndex); <span class="comment">//out: true 11</span></span><br></pre></td></tr></table></figure></p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>所以在没有必要的情况下，使用上面两个方法我们最好不要用‘g’标志。这样每次结果都不一样。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正则对象或字面量在加了’g’标志，进行全局匹配时，要注意test(),与exec()方法会更新RegExp.lastIndex的值。&lt;br&gt;
    
    </summary>
    
    
      <category term="RegExp" scheme="http://jekion.com/tags/RegExp/"/>
    
  </entry>
  
  <entry>
    <title>Generator函数笔记</title>
    <link href="http://jekion.com/2017/03/26/generator%20-%20todo/"/>
    <id>http://jekion.com/2017/03/26/generator - todo/</id>
    <published>2017-03-26T05:10:59.000Z</published>
    <updated>2019-06-06T23:21:04.198Z</updated>
    
    <content type="html"><![CDATA[<p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。<br><a id="more"></a></p><h3 id="yield表达式注意问题："><a href="#yield表达式注意问题：" class="headerlink" title="yield表达式注意问题："></a>yield表达式注意问题：</h3><p>1）<code>yield</code>表达式只有当调用<code>next</code>方法，内部指针指向该语句时才会执行；如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">funtion* gen()&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">111</span>+<span class="number">111</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>111+111</code>,不会立即求值，只会在next方法将指针移到这一句时，才会求值。<br>2）与<code>return</code>的区别<br>yield表达式只能存在Generator函数中可以多次，<code>return</code>任何函数中都可以；只能出现一次，return处在Generator中，与处在其他<br>函数中一样会中止generator函数执行; return 后面表达式的值做为<code>next()</code>的返回对象的<code>value</code>,<code>done</code>属性为true；</p><p>3）yield表达式用在另一表达式中，必须放在圆括号里面。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>+<span class="keyword">yield</span> <span class="number">123</span>); <span class="comment">//SyntaxError</span></span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">3</span> * <span class="keyword">yield</span> <span class="number">1</span> <span class="comment">//SyntaxError</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>+(<span class="keyword">yield</span> <span class="number">123</span>)); <span class="comment">//ok</span></span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">3</span> * (<span class="keyword">yield</span> <span class="number">1</span>) <span class="comment">//ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="for-…of循环。"><a href="#for-…of循环。" class="headerlink" title="for …of循环。"></a>for …of循环。</h3><p>for…of循环可以自动遍历 Generator 函数时生成的Iterator对象；不需要调用next方法；<br>值的注意的是：</p><blockquote><p>一旦next方法的返回对象的done属性为true，for…of<br>循环就会中止，且不包含该返回对象，所以下面代码的return语句返回的6，不包括在for…of循环之中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br></pre></td></tr></table></figure></p></blockquote><p>不仅<code>for...of</code>，扩展运算符<code>...</code>，Array.form()操作Iterator对象一样。</p><blockquote><p>for …of 可以遍历一切具有<code>Symbol.iterator</code>属性的对象，如<code>Array</code>,<code>Set</code>,’Map’;对于普通Object对象我们可以扩展<code>Symbol.iterator</code>属性达到可遍历的目的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name:<span class="string">'zhangsan'</span>,</span><br><span class="line">  age:<span class="string">'12'</span></span><br><span class="line">&#125;</span><br><span class="line">obj[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> keys)&#123;</span><br><span class="line">    <span class="keyword">yield</span> [key,<span class="keyword">this</span>[key]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [<span class="string">'bbbb'</span>,<span class="string">'cccreturn'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key,v] <span class="keyword">of</span> obj)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key+<span class="string">":"</span>+v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gfun = obj[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key,v] <span class="keyword">of</span> gfun)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure></p></blockquote><h3 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw();"></a>Generator.prototype.throw();</h3><p>1）Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。<br>如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(内部捕获：,e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iobj = gen();</span><br><span class="line">iobj.next() <span class="comment">//2</span></span><br><span class="line">iobj.throw(<span class="string">'b'</span>) <span class="comment">//内部捕获：b</span></span><br><span class="line">iobj.next() <span class="comment">//&#123;value:undefined,done:true&#125;</span></span><br></pre></td></tr></table></figure></p><p>内部捕获后，再遍历结束，调next()返回<code>{value:undefined,done:true}</code>如果内部没有部署<code>try...catch</code>(或内部部署了，但多次调用throw()除第一次内部捕获)则异常会抛到函数外部，外部可以捕获：<br>如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iobj = gen();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  iobj.next() <span class="comment">//2</span></span><br><span class="line">  iobj.throw(<span class="string">'b'</span>)</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(外部捕获：,e);  <span class="comment">//内部捕获：b</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">iobj.next() <span class="comment">//返回&#123;value:undefined,done:true&#125; 不会报错。</span></span><br></pre></td></tr></table></figure></p><p>如果内部外部都没有部署<code>try...catch</code> 则导致程序报错，中断执行。</p><p>2）Generator 函数体内抛出的错误，也可以被函数体外的catch捕获。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> y = x.toUpperCase();</span><br><span class="line">  <span class="keyword">yield</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo();</span><br><span class="line"></span><br><span class="line">it.next(); <span class="comment">// &#123; value:3, done:false &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  it.next(<span class="number">42</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a>Generator.prototype.return()</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。&lt;br&gt;
    
    </summary>
    
    
      <category term="generator" scheme="http://jekion.com/tags/generator/"/>
    
  </entry>
  
  <entry>
    <title>Cannot read property &#39;EventSource&#39; of undefined</title>
    <link href="http://jekion.com/2017/03/15/eventsource/"/>
    <id>http://jekion.com/2017/03/15/eventsource/</id>
    <published>2017-03-15T05:10:59.000Z</published>
    <updated>2019-06-06T23:21:04.089Z</updated>
    
    <content type="html"><![CDATA[<p><code>webpack</code>热加载，再加入<code>babel</code>加载器之后，莫明报了这个错<code>Cannot read property &#39;EventSource&#39; of undefined</code>;<br>这个坑浪费了我一个上午时间去填…<br><a id="more"></a></p><h3 id="引发原因"><a href="#引发原因" class="headerlink" title="引发原因"></a>引发原因</h3><p>配置在加入<code>babel</code>之前是好的，加入之后控制台就报上面的错，配置如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>花费这么长时间排查的主要原因是在加入babel之后又进行了一系列的其他配置才发现热加载出现问题（一直没有关注控制台，因为编译一切正常）;让我一下子摸不到头脑。以为代码哪里写错，怎么也没有让我怀疑到是这个加载器有问题（什么问题后面讲）；花了很时间比较撤销也没有找到原因，<code>google</code>发现也有朋友出现类似问题，其中有一个描述是由加载器导致出错，回头看我的加载器配置只有一个<code>babel</code>推测是不是它，是不是因为没有加<code>include</code>加限止，导致他干扰了<code>eventsource-polyfill</code>模块？</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>果断加上<code>include</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">  include:[path.resolve(__dirname,<span class="string">"../src"</span>)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>问题解决。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;webpack&lt;/code&gt;热加载，再加入&lt;code&gt;babel&lt;/code&gt;加载器之后，莫明报了这个错&lt;code&gt;Cannot read property &amp;#39;EventSource&amp;#39; of undefined&lt;/code&gt;;&lt;br&gt;这个坑浪费了我一个上午时间去填…&lt;br&gt;
    
    </summary>
    
    
      <category term="webpack" scheme="http://jekion.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>左侧宽度固定，右侧宽度自适应布局CSS怎么实现</title>
    <link href="http://jekion.com/2017/01/08/css_flex_auto/"/>
    <id>http://jekion.com/2017/01/08/css_flex_auto/</id>
    <published>2017-01-08T15:10:59.000Z</published>
    <updated>2019-06-06T23:21:03.995Z</updated>
    
    <content type="html"><![CDATA[<p>今天同事问我左侧宽度固定，右侧宽度自适应布局CSS怎么实现，我首先想到是<code>flex</code>布局；但又隐约感觉还有其他方法，并且应该不止一两种。不敢确定（有点慌）；于是赶紧写几个DEMO实现一下；下面是目前想出的三种方式，应该还有，有了解的伙伴欢迎留言交流：</p><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>1111<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>aaaaa<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="selector-tag">html</span>,<span class="selector-tag">body</span>&#123;<span class="attribute">width</span>:<span class="number">100%</span>; <span class="attribute">height</span>: <span class="number">100%</span>;<span class="attribute">padding</span>:<span class="number">0</span>;<span class="attribute">margin</span>:<span class="number">0</span>;&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;<span class="attribute">width</span>:<span class="number">200px</span>;<span class="attribute">height</span>:<span class="number">200px</span>;<span class="attribute">float</span>:left; <span class="attribute">background</span>: green;&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;<span class="attribute">height</span>:<span class="number">200px</span>;<span class="attribute">background</span>:red; <span class="attribute">margin-left</span>:<span class="number">200px</span>;&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span>       </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap-right"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right-inner"</span>&gt;</span>asdfasfadfasdfsadfsaf ss ssa aad asdf aasd aaa <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap-left"</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>右边。<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span>&#123;<span class="attribute">width</span>: <span class="number">100%</span>; <span class="attribute">height</span>: <span class="number">300px</span>;&#125;</span><br><span class="line"><span class="selector-class">.wrap-left</span>&#123; <span class="attribute">width</span>: <span class="number">300px</span>; <span class="attribute">float</span>: left; <span class="attribute">height</span>: <span class="number">300px</span>; <span class="attribute">background</span>: <span class="number">#eee</span>; <span class="attribute">margin-right</span>:-<span class="number">300px</span>; <span class="attribute">z-index</span>: <span class="number">20</span>; &#125;</span><br><span class="line"><span class="selector-class">.wrap-right</span>&#123;<span class="attribute">width</span>: <span class="number">100%</span>; <span class="attribute">height</span>: <span class="number">300px</span>; <span class="attribute">float</span>: right; <span class="attribute">background</span>: <span class="number">#ccc</span>;&#125;</span><br><span class="line"><span class="selector-class">.right-inner</span>&#123; <span class="attribute">margin-left</span>:<span class="number">300px</span>; &#125;</span><br></pre></td></tr></table></figure><h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flex-warp"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flex-left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flex-right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-warp</span>&#123;<span class="attribute">width</span>: <span class="number">100%</span>; <span class="attribute">height</span>: <span class="number">300px</span>; <span class="attribute">display</span>: flex;<span class="attribute">display</span>: -webkit-flex;&#125;</span><br><span class="line"><span class="selector-class">.flex-left</span>&#123;<span class="attribute">min-width</span>: <span class="number">200px</span>; <span class="attribute">height</span>: <span class="number">300px</span>; <span class="attribute">background</span>:green;&#125;</span><br><span class="line"><span class="selector-class">.flex-right</span>&#123;<span class="attribute">width</span>: <span class="number">100%</span>; <span class="attribute">height</span>: <span class="number">300px</span>; <span class="attribute">background</span>:red;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天同事问我左侧宽度固定，右侧宽度自适应布局CSS怎么实现，我首先想到是&lt;code&gt;flex&lt;/code&gt;布局；但又隐约感觉还有其他方法，并且应该不止一两种。不敢确定（有点慌）；于是赶紧写几个DEMO实现一下；下面是目前想出的三种方式，应该还有，有了解的伙伴欢迎留言交流：&lt;
      
    
    </summary>
    
    
      <category term="CSS" scheme="http://jekion.com/tags/CSS/"/>
    
  </entry>
  
</feed>
